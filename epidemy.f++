.apply(function() {
//epidemyInit = function() {
    var fillEmotes;

    if(.tmp.epidemy==null) .tmp.epidemy = .Map();

    this = .tmp.epidemy;

    if(infectedList==null) infectedList = .List();

    preInfect = function(vict, ch) {
        var invaderName;
        if(vict.epidemy==null)
            vict.epidemy = .Map();

        if(ch.is_npc()) {
            if(ch.epidemy!=null) {
                invaderName=ch.epidemy.invader;
            } else {
                invaderName='unknown';
            }
        } else {
            invaderName = ch.name;
        }
        vict.epidemy.invader = invaderName;
        vict.epidemy.status = 'inited';
        vict.postSpec = function(){if(.chance(10)) {.tmp.epidemy.infect(this);}};
        regStat(invaderName,'infect');
    };
    infect = function(mob) {
        this = .tmp.epidemy;

        //всё равно заболеет, заносим в список
        if(mob.epidemy==null) //должно быть создано в preInfect
            mob.epidemy = .Map();

        mob.epidemy.status = 'infected';
        //mob.epidemy.infected = true;

        infectedList.push_back(mob);

        mob = setInfectedTriggers(mob);
    };
    transform = function(mob) {
        this = .tmp.epidemy;
        //тёмные силы победили! УРА!
        //выворачиваем зверюгу наизнанку
        try{
            mob = evert(mob);
            mob = setSickTriggers(mob);
            mob.epidemy.status = 'sick';
            clearPlan(mob);
        }catch(e) {
            throw('->transform:'+e);
        }
    };
    getVictims = function(mob) {
        var count,i,l,vict;
        var result;

        result = .List();
        for(vict in mob.in_room.ppl) {
            if(vict==mob) continue;
            if(!vict.is_npc()) continue;
            if(vict.epidemy!=null) continue;

            if(vict.size <= mob.size //малышей кусь
                || (vict.leader!=null && vict.leader.pet==vict)) { //петов кусь
                result.push_back(vict);
            }
        }
        return result;
    };
    evert = function(mob) {
        try{
            this = .tmp.epidemy;
            if(mob.epidemy==null)
                mob.epidemy=.Map();

            var match;

            var long_descr;
            var enName;
            var regexp;

            var short_descr;
            var description;

            var name, tmp_name;
            var nameList;
            long_descr = 'Вывернутое наизнанку существо {D#runame{x {Y(#enname{Y) ходит тут задом наперед.\n';
            description = 'Отвратительное существо, вывернутое внутренностями наружу (несомненно какой-то\n' +
                '{Dтемной{x магией), {D#runame{x ходит здесь задом наперед. Лучше держаться\n' +
                'от ЭТОГО подальше, чтоб не укусило (страшно представить каким местом).\n' +
                'Из черных глаз существа вырываются еле заметные языки феолетово-черного пламени.\n\n';

            short_descr = reverseStr(.fmt('%1C1',mob));

            tmp_name = mob.name.stripColour();
            tmp_name = tmp_name.replace('  ',' ');
            tmp_name = tmp_name.replace('(','');
            tmp_name = tmp_name.replace(')','');
            tmp_name = tmp_name.replace(']','');
            tmp_name = tmp_name.replace('[','');
            tmp_name = tmp_name.replace('{','');
            tmp_name = tmp_name.replace('}','');

            regexp = ' \\((' + tmp_name.replace(' ','|') + ')\\) ';
            match = mob.long_descr.matchGroups(regexp);

            if(match.size()) {
                long_descr = long_descr.replace('#enname', '{D'+reverseStr(match.back())+'{x');
            } else {
                long_descr = long_descr.replace('\{Y\(#enname\{Y\) ','{Y');
            }

            nameList = ((short_descr+' '+reverseStr(mob.name)).split(' ')).sort().unique();

            name = '';
            var i; var size;
            size = nameList.size();
            for(i=1;i<=size;i=i+1) {
                name = name+nameList.front();
                nameList.pop_front();
                if(i<size)
                    name = name + ' ';
            }

            mob.recho("{DТёмные силы{x выворачивают %1$C4 наизнанку, превращая в {D"+short_descr+"{x. Фууууууу!", mob);

            long_descr = long_descr.replace('#runame',short_descr);
            description = description.replace('#runame',short_descr);

            // меняем описания, и сохраняем старые для выздоравливания.
            mob.epidemy.long_descr = mob.long_descr;
            mob.long_descr = long_descr;

            mob.epidemy.short_descr = mob.short_descr;
            mob.short_descr = '{D'+short_descr+'{x';

            mob.epidemy.description = mob.description;
            mob.description = description;

            mob.epidemy.name = mob.name;
            mob.name = name;

            mob.epidemy.alignment = mob.alignment;
            mob.alignment = -1000;

            return mob;
        }catch(e){throw('->evert:'+e);}
    };
    reverseStr = function(str) {
        try{
            var newStr;
            var alfa;
            var i;

            newStr = '';
            str = str.stripColour();
            for( i=0; i<80; i=i+1) {
                alfa = str.substr(i,1).toLower();
                if(alfa.match('[- йуёеъыаоэяиью]{1}|^$') && newStr.match('^[ьъ]')) {
                    newStr = newStr.substr(1);
                }

                if(alfa=='')
                    break;

                newStr = alfa + newStr;
            }

            return newStr;
        }catch(e){throw('->reverseStr:'+e);}
    };
    plan_cancel = function(mob) {
        this = .tmp.epidemy;

        var total;
        var i, l, m;

        l = infectedList.clone();
        total = l.size();

        for( i=1 ; i<=total ; i=i+1 ) {
            m = l.back();
            if(m==null) continue;
            if(m.dead || m.epidemy==null) {
                infectedList.sub(m);
                continue;
            } else if(m.in_room.areaname==mob.in_room.areaname) {
                clearPlan(m);
            }
            l.pop_back();
        }

    };
    clearPlan = function(mob){
        mob.epidemy.plan = null;
        clearGPS(mob);
    };
    clearGPS = function(mob){
        mob.epidemy.plan_room = null;
        mob.epidemy.plan_waypoint = null;
        mob.epidemy.plan_nextroom = null;
        mob.epidemy.plan_way = null;
    };
    plan_check = function(mob) {
        try{
            /*
            * 0 - ты не последний зараженный
            * 1 - все заражены - собираемся до кучи
            * 2 - ты в куче, ждем остальных
            * 3 - я последний - вызываем "КРАКЕНА"
            */
            this = .tmp.epidemy;

            debug(mob,'pl_chk 0:start');

            var result;
            var total, city, plan_room;
            var i,mlist,m,fidovnum;
            var planG, planD;
            var actualCityInfectedList;
            planG = true; planD = true;
            city = mob.in_room.areaname;
            actualCityInfectedList = .List();
            result = 3;

            if(mob.epidemy.plan_room==null) {
                plan_room = mob.in_room;
            } else {
                plan_room = mob.epidemy.plan_room;
            }
            debug(mob,'pl_chk 0.1: plan_room:'+plan_room.vnum);

            //пересчёт зараженных в городе
            mlist = infectedList.clone();
            total = mlist.size();
            for( i=1 ; i<=total ; i=i+1 ) {
                m = mlist.back();
                mlist.pop_back();
                if(m.dead) {
                    infectedList.sub(m);
                    continue;
                }
                if (!m.online || (m.leader != null && m.leader.pet == m)) {
                    continue;
                }
                //тварь в нашем городе
                if (m.in_room.areaname == city){
                    actualCityInfectedList.push_back(m);
                    if(m.epidemy.status!='sick') {
                        planG = false;
                        debug(mob,'pl_chk 0.2: '+m.name+'('+m.in_room.vnum+')'+' status:'+m.epidemy.status+'->planG=null');
                    }
                    if(m.in_room != mob.in_room) {
                        planD = false;
                        debug(mob,'pl_chk 0.3: '+m.name+'('+m.in_room.vnum+')'+' not in '+plan_room.vnum+'->planD=null');
                    }

                    //фидо-лайк-тварь (их и будем проверять)
                    if(m.pIndexData.spec_fun == 'spec_fido') {
                        fidovnum = m.pIndexData.vnum;
                    }
                }
            }
            for(imp in imps) {
                if (imp.in_room.areaname == city){
                    actualCityInfectedList.push_back(imp);
                    if(imp.in_room != mob.in_room) {
                        planD = false;
                    }
                }
            }

            debug(mob,'pl_chk 1: infected:'+actualCityInfectedList.size()+' planG:'+planG+' planD:'+planD);

            if(actualCityInfectedList.size()<13) {
                planG = false; planD = false; result = 0;
                debug(mob,'pl_chk 2.1: planD=false; planG=false; result='+result);
            } else {
                //должны быть заражены все fido-like
                var allFidoInfected; allFidoInfected = true;
                if(fidovnum!=null) {
                    debug(mob,'pl_chk 2.2: fidovnum:'+fidovnum);
                    for( m in .get_mob_index(fidovnum).instances) {
                        //тварь в нашем городе, но не инфицирована
                        if(m.in_room.areaname==city && (m.epidemy==null || m.epidemy.status==null || m.epidemy.status!='sick')){
                            allFidoInfected = false;
                            planG = false; planD = false; result = 0;
                            debug(mob,'pl_chk 2.3: planD=false; planG=false; result='+result);
                            break;
                        }
                    }
                }
            }

            if(!planD) {
                if(planG){
                    if(mob.in_room!=plan_room)
                        result=1;
                    else
                        result=2;
                } else {
                    result=0;
                }
                debug(mob,'pl_chk 4: no PlanD; result:'+result);

                if(mob.epidemy.plan==null && mob.epidemy.plan_room==null) {
                    for (m in actualCityInfectedList) {
                        clearGPS(m);
                        if(planG) {
                            //если планГ утвержден, прописываем всем в городе
                            if(m.in_room==plan_room) {
                                m.epidemy.plan = 2;
                            } else {
                                m.epidemy.plan = 1;
                            }
                            m.epidemy.plan_room = plan_room;
                        } else {
                            //ни у кого нет плана
                            m.epidemy.plan = 0;
                        }
                    }
                }
            } else {
                result = 3;
            }

            debug(mob,'pl_chk 11: end. result: '+result+' plan_room:'+plan_room.vnum);
            if(mob.epidemy.plan==null) {
                debug(mob,'pl_chk 11.1: end. mob.plan:null');
            }
            if(mob.epidemy.plan_room==null) {
                debug(mob,'pl_chk 11.2: end. mob.plan_room:null');
            }
            return result;
        }catch(e){
            .tmp.epidemy.catchMsg(e);
        }
    };
    explode_in_room = function(room) {
        this = .tmp.epidemy;
        var ash;
        try {
        room.echo('Отвратительные существа вспыхивают темно-фиолетовым пламенем...');
        for(mob in room.ppl) {
            if(mob.dead) {
                infectedList.sub(mob);
                imps.sub(mob);
            } else {
                if(!mob.is_npc()
                    || mob.epidemy==null) continue;
                if(mob.epidemy.status==null) throw(.fmt('epidemy->explode_in_room(): %1$C1 %2$s[%3$d]',mob,room.name, room.vnum)+' incorrect epidemy structure (status==null)');
                if(mob.epidemy.status!='imp' && mob.epidemy.status!='sick') continue;
                if(mob.leader!=null && mob.leader.pet==mob) {
                    //петов, так и быть, появление демона лечит (если они в этой комнате)
                    room.echo('Частица {DТьмы{x вырывается из %1C1 наружу.',mob);
                    heal(mob,null);
                } else {
                    if(mob.epidemy.status=='imp') {
                        imps.sub(mob);
                    } else {
                        infectedList.sub(mob);
                    }
                    ash = .get_obj_index(.tmp.epidemy.ashVnum).create();
                    ash.obj_to_room(room);
                    ash.timer = 5;
                    ash.description = .fmt('Горсть пепла (ash) останков %1C2 лежит у твоих ног.', mob);

                    mob.extract(true);
                }

            }
        }

        } catch(e) {
            catchMsg("epidemy.explode_in_room: " + e);
        }
    };

    str_utterance = function(str) {
        var new_str, tmp_str;

        var syl_table;
        syl_table = .Array();
        syl_table[' '] = ' ';
        syl_table['ar'] = 'abra';
        syl_table['au'] = 'kada';
        syl_table['bless'] = 'fido';
        syl_table['blind'] = 'nose';
        syl_table['bur'] = 'mosa';
        syl_table['cu'] = 'judi';
        syl_table['de'] = 'oculo';
        syl_table['en'] = 'unso';
        syl_table['light'] = 'dies';
        syl_table['lo'] = 'hi';
        syl_table['mor'] = 'zak';
        syl_table['move'] = 'sido';
        syl_table['ness'] = 'lacri';
        syl_table['ning'] = 'illa';
        syl_table['per'] = 'duda';
        syl_table['ra'] = 'gru';
        syl_table['fresh'] = 'ima';
        syl_table['re'] = 'candus';
        syl_table['son'] = 'sabru';
        syl_table['tect'] = 'infra';
        syl_table['tri'] = 'cula';
        syl_table['ven'] = 'nofo';
        syl_table['ust'] = 'lon';
        syl_table['a'] = 'a'; syl_table['b'] = 'b'; syl_table['c'] = 'q'; syl_table['d'] = 'e';
        syl_table['e'] = 'z'; syl_table['f'] = 'y'; syl_table['g'] = 'o'; syl_table['h'] = 'p';
        syl_table['i'] = 'u'; syl_table['j'] = 'y'; syl_table['k'] = 't'; syl_table['l'] = 'r';
        syl_table['m'] = 'w'; syl_table['n'] = 'i'; syl_table['o'] = 'a'; syl_table['p'] = 's';
        syl_table['q'] = 'd'; syl_table['r'] = 'f'; syl_table['s'] = 'g'; syl_table['t'] = 'h';
        syl_table['u'] = 'j'; syl_table['v'] = 'z'; syl_table['w'] = 'x'; syl_table['x'] = 'n';
        syl_table['y'] = 'l'; syl_table['z'] = 'k';
        syl_table[''] = ''; syl_table['-'] = '-';

        tmp_str = str; new_str = '';
        var len,i; i = 100;
        for(len=tmp_str.size();len>0;len=tmp_str.size()) {
            for(old in syl_table.keys){
                if(old.strPrefix(tmp_str)) {
                    new_str=new_str+syl_table[old];
                    tmp_str=tmp_str.substr(old.size());
                }
            }
            i=i-1;
            if(i<=0)
                return str;
        }

        return new_str;

    };

    fillEmotes = function(){
        this = .tmp.epidemy;

        //массивы социалов для зараженных
        emoteArray = .Array();
        emoteArray[0] = 'bounce self';  emoteArray[1] = 'burp self';
        emoteArray[2] = 'burp';         emoteArray[3] = 'confused';
        emoteArray[4] = 'conspire';     emoteArray[5] = 'cough';
        emoteArray[6] = 'fart';         emoteArray[7] = 'glare';
        emoteArray[8] = 'grimace';      emoteArray[9] = 'growl';
        emoteArray[10] = 'lick self';   emoteArray[11] = 'moan';
        emoteArray[12] = 'nail self';   emoteArray[13] = 'puke';
        emoteArray[14] = 'stagger';     emoteArray[15] = 'slobber';
        emoteArray[16] = 'twitch';      emoteArray[17] = 'wince';
        emoteArray[18] = 'fume';        emoteArray[19] = 'flinch';
        emoteArray[20] = 'rub self';    emoteArray[21] = 'sneeze';

        emoteTargArray = .Array();
        emoteTargArray[0] = "puke";
        emoteTargArray[1] = "stagger";
        emoteTargArray[2] = "growl";
    };

    if(triggers == null)
        triggers = .Map();

    triggers.infectedPostSpec = function(mob){
        try{
            this = .tmp.epidemy;

            if(.chance(1)) {
                transform(mob);
            } else if(.chance(5)) {
                mob.act("Ты корчишься в мучениях сопротивляясь {Dтёмным силам{x внутри себя!");
                mob.recho("%1$^C1 дрожит и корчится сопротивляясь {Dтёмным силам{x внутри себя!", mob);
            }
        }catch(e){
            e= 'epidemy.infectedPostSpec:'+e;
            if(!mob.dead) {
                e = e + .fmt(' (%1$C1[%5$d] %2$s[%3$d](%4$s))',mob, mob.in_room.name,mob.in_room.vnum, mob.in_room.areaname, mob.pIndexData.vnum);
            }

        .tmp.epidemy.catchMsg(e);
        }
    };
    triggers.sickPostSpec = function (mob) {
        if(mob.dead) return;

        this = .tmp.epidemy;

        try {
            if(mob.epidemy.plan!=null)
                debug(mob,'postSpec 0: start. plan:'+mob.epidemy.plan);
            else
                debug(mob,'postSpec 0: start. plan:null');

            if(mob.epidemy==null) throw('NO epidemy Map\n');

            if(mob.epidemy.victims==null) {
                mob.epidemy.victims = getVictims(mob);
            }
            debug(mob,'postSpec 1: victims:'+mob.epidemy.victims.size());

            if(mob.epidemy.plan != null && mob.epidemy.plan >= 1 && mob.epidemy.plan_room==null) {
                mob.epidemy.plan = null;
                debug(mob,'postSpec 2: no plan_room -> plan=null');
            }

            if(mob.epidemy.plan == null) {
                mob.epidemy.plan = plan_check(mob);
                debug(mob,'postSpec 3: after plan_check: plan:'+mob.epidemy.plan);
            }

            if(mob.epidemy.plan == 2 && mob.epidemy.plan_room!=mob.in_room) {
                debug(mob,'postSpec 4: in '+mob.in_room.vnum+' not in plan_room '+mob.epidemy.plan_room.vnum+': plan:'+mob.epidemy.plan+'->1');
                mob.epidemy.plan = 1;
            }
            if(mob.epidemy.plan == 1 && mob.epidemy.plan_room==mob.in_room) {
                mob.epidemy.plan = null;
                debug(mob,'postSpec 5: in plan_room: plan=null');
            }

            if(mob.epidemy.plan == 3) {
//                    debug(mob,'postSpec 6: plan:'+mob.epidemy.plan+'. check plan...');
                //бывает что какая-то зверюга убегает в последний момент
                mob.epidemy.plan = plan_check(mob);
//                    debug(mob,'postSpec 7: after plan_check plan:'+mob.epidemy.plan);
                //и если план без изменений
                if(mob.epidemy.plan == 3) {
//                        debug(mob,'postSpec 8: demon time.');

                    var demon_room,invader;

                    demon_room = mob.in_room;
                    invader = mob.epidemy.invader;
                    //взорвать всех зверюг в комнате
                    explode_in_room(demon_room);
                    //вызывать демона
                    get_one_demon(demon_room,invader);

                    return;
                }
            }

            //собака-кусака!
            if(mob.epidemy.victims.size() && .chance(10)) {
                debug(mob,'postSpec 9: собака-кусака');
                //кусаем если есть кого
                var vict;
                vict = mob.epidemy.victims.random();
                if(vict.dead || !vict.online || vict.in_room!=mob.in_room || vict.epidemy!=null){
                    //изчез куда-то гад!!!
                    mob.epidemy.victims = null;
                } else {
                    /*---некотролируемая эпидемия начинается здесь---*/
                    mob.act("Повинуясь {Dтёмным силам{x внутри себя, ты кусаешь %1$C2!", vict);
                    vict.act("Повинуясь {Dтёмным силам{x внутри себя, %1$C1 кусает тебя.{/Частичка {Dтемных сил{x проникает в тебя!", mob);
                    mob.rvecho(vict,"%1$^C1, повинуясь {Dтёмным силам{x внутри себя, кусает %2$C4.{/Частичка {Dтёмных сил{x проникает в %2$C4!", mob, vict);
                    preInfect(vict,mob);//.postSpec = function(){if(.chance(10)) {.tmp.epidemy.infect(this);}};
                    /*----------------------------------------------*/
                    mob.epidemy.victims.sub(vict);
                }
                return;
            }

            //собака - гуляка!
            /*plan:
            * 0 - ты не последний зараженный
            * 1 - все заражены - собираемся до кучи
            * 2 - ты в куче, ждем остальных
            * 3 - я последний - вызываем "КРАКЕНА"
            */
            if(mob.epidemy.plan==1 && .chance(50) && !(mob.leader!=null && mob.leader.pet==mob)) {
                debug(mob,'postSpec 10: собака-гуляка');
                if(!(mob.position&.tables.position_table.stand)){
                    mob.interpret('stand');
                    return;
                }

                if(mob.epidemy.plan_room==null)
                    throw('собака-гуляка '+mob.name+':plan_room==null;in_room:'+mob.in_room.name+'('+mob.in_room.vnum+')\n');

                if(mob.epidemy.plan_way==null) {
                    debug(mob,'postSpec 10.1: no plan_way');
                    if(!mob.epidemy.plan_room.isCommon()) {
                        debug(mob,'postSpec 10.1.1: plan_room isCommon');
                        mob.epidemy.plan = null;
                        mob.epidemy.plan_room = null;
                        //return;
                    } else {
                        //ищем путь
                        debug(mob,'postSpec 10.1.2: try to find way');
                        mob.interpret('ponder');
                        mob.epidemy.plan_way = find_way(mob,mob.epidemy.plan_room);
                        if(mob.epidemy.plan_way.size()>0){
                            debug(mob,'postSpec 10.1.3: way size:'+mob.epidemy.plan_way.size());
                            mob.epidemy.plan_waypoint = mob.in_room;
                            return;
                        } else {
                            debug(mob,'postSpec 10.1.4: беда! пустой маршрут');
                            // беда! пустой маршрут
                        }
                    }
                } else if(mob.epidemy.plan_nextroom == null) {
                    debug(mob,'postSpec 10.2: plan_nextroom==null. try to make move');
                    make_your_move(mob);
                } else if (mob.epidemy.plan_waypoint!=mob.in_room) { //сбились с маршрута
                    debug(mob,'postSpec 10.3: plan_waypoint!=mob.in_room. сбились с маршрута');
                    mob.epidemy.plan_waypoint = null;
                    mob.epidemy.plan_nextroom = null;
                    mob.epidemy.plan_way = null;
                } else { //маршрут есть и мы с него не сбились
                    debug(mob,'postSpec 10.4: on my way');
                    if(.chance(20)) {
                        debug(mob,'postSpec 10.4.1: my chance');
                        var exitDoor;
                        exitDoor = mob.in_room.doorTo(mob.epidemy.plan_nextroom);

                        if(mob.in_room.getExitFlags(exitDoor) & .tables.exit_flags.closed) {
                            debug(mob,'postSpec 10.4.1.1: двери будь они неладны');

                            if(.chanceOneOf(4))
                            {
                                mob.recho('%1$^C1 бьётся головой в %2$N4. Закрыто.',mob,mob.in_room.exitShortDescr(exitDoor));
                            }
                        else if(.chanceOneOf(3))
                            {
                                mob.recho('%1$^C1 жалобно скулит и скребётся в %2$N4. Тщетно.',mob, mob.in_room.exitShortDescr(exitDoor));
                            }
                        else if (.chanceOneOf(2))
                            {
                                var ppllist, sucker;
                                ppllist = mob.in_room.ppl.clone();
                                ppllist.sub(mob);
                                if(ppllist.size()>0) {
                                    sucker = ppllist.random();
                                    sucker.recho('%1$^C1 садится перед %2$N5, и жалобно смотрит в глаза %3$C3.',mob, mob.in_room.exitShortDescr(exitDoor), sucker);
                                    sucker.act('%1$^C1 садится перед %2$N5, и жалобно смотрит тебе в глаза.',mob, mob.in_room.exitShortDescr(exitDoor));
                                } else {
                                    mob.recho('%1$^C1 садится перед %2$N5, и жалобно завывает.',mob, mob.in_room.exitShortDescr(exitDoor));
                                }
                            }
                        else
                            {
                                mob.recho('На мгновение в глазах %1$C1 вспыхивает искра интеллекта.',mob);
                                mob.interpret('open '+mob.in_room.doorName(exitDoor));
                            }

                            return;
                        } else {
//                                debug(mob,'postSpec 10.4.1.2: need a second chance');

                            if(.chanceOneOf(3)) {
                                mob.recho("%1$^C1 ходит кругами и нюхает следы. Этим что, можно ещё и нюхать?!",mob);
                            } else if(.chanceOneOf(2)) {
                                mob.in_room.ppl.forEach(function (mob) {act("%1$^C1 принюхивается. Ты и представить себе не мог%2$Gло||ла, что ЭТИМ можно нюхать!",mob,this);},mob);

                            } else {
//                                    debug(mob,'postSpec 10.4.1.2.3: try to make a move');

                                make_your_move(mob);

                            }
                            return;
                        }


                    } else {
                        debug(mob,'postSpec 10.4.2: not a chance');

                    }
                }
            }

            //собака-кривляка!
            if(.chance(5)) {
                debug(mob,'postSpec 12: собака-кривляка');

                //спамим всякими социалами
                if (mob.in_room.ppl.size()<2)
                    return;

                var numba,temotes,emotes;
                emotes = emoteArray.keys.size();
                temotes = emoteTargArray.keys.size();
                numba = .number_range(0, (temotes+emotes-1));

                if (numba > (emotes-1)) {
                    var target;
                    var str;
                    numba = numba - emotes;

                    if(emoteTargArray[numba]==null)
                        throw 'epidemy: mob.onSpec: нет такой emoteTargArray';

                    for(target=mob.in_room.ppl.random();target==mob;target=mob.in_room.ppl.random()) {}

                    str = emoteTargArray[numba] + ' ' + target.name;
                    mob.interpret(str);
                } else {
                    mob.interpret(emoteArray[numba]);
                }
                return;
            }
        } catch(e){
            e= 'epidemy.sickPostSpec:'+e;
            if(!mob.dead) {
                e = e + .fmt(' (%1$C1[%5$d] %2$s[%3$d](%4$s))',mob, mob.in_room.name,mob.in_room.vnum, mob.in_room.areaname, mob.pIndexData.vnum);
            }

        .tmp.epidemy.catchMsg(e);
        }
    };
    triggers.infectedOnSpell = function(mob, ch,spell,before) {
        /*onSpell(ch, spell, before) - ch пытается колдовать на нас заклинание spell,
        где spell - англ название умения. Вызывается дважды, причем before будет равно true перед кастом,
        и false - после каста. Если вернуть true из первого вызова, то заклинание выполнено не будет.
        Если вернуть true из второго вызова, то отрицательной реакции на атакующее заклинание не последует.  */
        this = .tmp.epidemy;
        //dispel evil
        if(before){
            if(spell == 'dispel evil' || spell == 'heal' || spell == 'superior heal') {
                mob.recho("%1$^C1 одной стороной чихает, другой выпускает {Dтёмное облочко{x...", mob);
                return true;
            }
        } else {
            if(spell == 'dispel evil' || spell == 'heal' || spell == 'superior heal') {
                heal(mob, ch);
                return true;
            }
        }
        //ray of truth
        return false;
    };
    triggers.sickOnSpell = function(mob,ch,spell,before) {
        this=.tmp.epidemy;
        //dispel evil
        if(before){
            if(spell == 'dispel evil' || spell == 'ray of truth'
                || spell == 'wrath' || spell == 'banishment') {
                mob.recho("%1$^C1 одной стороной чихает, другой выпускает {Dтёмное облочко{x...", mob);
                return true;
            }
        } else {
            if(spell == 'dispel evil' || spell == 'ray of truth'
                || spell == 'wrath' || spell == 'banishment') {
                heal(mob,ch);
                return true;
            }
        }
        //ray of truth
        return false;
    };
    triggers.infectedOnDeath = function(mob,ch) {
        //onDeath(ch) - ch убил нас. если вернуть true, мы не умрем и останемся стоять
        //выпиливаемся из списка
        .tmp.epidemy.infectedList.sub(mob);
    };
    triggers.infectedOnExtract = function(mob,count) {
        //выпиливаемся из списка
    .tmp.epidemy.infectedList.sub(mob);
    };
    triggers.sickOnLeave = function(mob, ch, from_room, movetype) {
        //onLeave(ch, from_room, movetype) - ch только что вышел из нашей комнаты
        mob.epidemy.victims = null;
    };
    triggers.sickOnEntry = function(mob) {
        //onEntry() - мы вошли в какую-то комнату
        mob.epidemy.victims = null;
    };
    triggers.sickOnGreet = function(mob, ch) {
        //onGreet(ch) - ch вошел в нашу комнату
        mob.epidemy.victims = null;
    };
    triggers.sickOnDeath = function(mob, ch) {
        //onDeath(ch) - ch убил нас. если вернуть true, мы не умрем и останемся стоять
        this=.tmp.epidemy;
        //выпиливаемся из списка
        if(mob.epidemy.status=='inverted')
            invertedList.sub(mob);
        else {
            infectedList.sub(mob);
            //отменяем план
            if(mob.epidemy.plan!=null)
                plan_cancel(mob);
        }

        //вылупляем импа
        if(ch!=null && imp_list!=null && imp_list.size()>0
            && initImp!=null && !imp_list.has(pIndexData)) {
            var imp;
            imp = imp_list.random().create();
            initImp(imp);
            imp.epidemy.invader=mob.epidemy.invader;
            imp.char_to_room(ch.in_room);
            regStat(mob.epidemy.invader,'imp');
            if(ch!=null) {
                regStat(getPCname(ch), 'imp_create');
            }
            imp.epidemy.fearList.push_back(ch);
            ch.in_room.echo('Из останков %1$C1, весь в кишках и ошметках, вылезает %2$C1.',mob,imp);
        }
    };

    setInfectedTriggers = function(mob) {
        mob.postSpec = function(){.tmp.epidemy.triggers.infectedPostSpec(this);};
        mob.onSpell = function(ch,spell,before){if(.tmp.epidemy.triggers.infectedOnSpell(this,ch,spell,before)) return true;};
        mob.onDeath = function(ch){.tmp.epidemy.triggers.infectedOnDeath(this,ch);};
        mob.onExtract = function(count){.tmp.epidemy.triggers.infectedOnExtract(this,count);};

        return mob;
    };
    setSickTriggers = function(mob) {
        try{
            mob.postSpec = function(){.tmp.epidemy.triggers.sickPostSpec(this);};
            mob.onSpell = function(ch,spell,before){if(.tmp.epidemy.triggers.sickOnSpell(this,ch,spell,before)) return true;};
            mob.onLeave = function(ch, from_room, movetype){.tmp.epidemy.triggers.sickOnLeave(this,ch, from_room, movetype);};
            mob.onEntry = function(){.tmp.epidemy.triggers.sickOnEntry(this);};
            mob.onGreet = function(ch){.tmp.epidemy.triggers.sickOnGreet(this, ch);};
            mob.onDeath = function(ch){.tmp.epidemy.triggers.sickOnDeath(this,ch);};

            return mob;
        }catch(e){throw('setSickTriggers:'+e);}
    };

    fillEmotes();
})

//Name: [fido dog зверюга] Vnum: [3062] Spec fun: [spec_fido] Size: [small]
//Name: [alley cat feline кот] Vnum: [9543] Size: [small]
//Name: [vulture стервятник] Vnum: [9544] Spec fun: [spec_fido] Size: [small]
//eval looking4fido = function(sf,ch) {for(i=.char_list;i!=null;i=i.next) {if(i.pc!=null) {continue;} if(i.pIndexData.spec_fun==sf) ch.ptc(''+i.pIndexData.vnum+i.name+'\n');}}
