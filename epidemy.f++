.apply(function() {
//epidemyInit = function() {
    var fillEmotes, fillTriggers, fillInfected;
    if(.tmp.epidemy==null) .tmp.epidemy = .Map();
    if(.tmp.epidemy.infected==null) .tmp.epidemy.infected = .List();
    if(.tmp.epidemy.warlocks==null) .tmp.epidemy.warlocks = .List();
    if(.tmp.epidemy.books==null) .tmp.epidemy.books=.Array();
    if(.tmp.epidemy.demons==null) .tmp.epidemy.books=.List();

    //this = .tmp.epidemy;

.tmp.epidemy.bookkeeper = .get_mob_index(761);
.tmp.epidemy.necronomicon = .get_obj_index(732);
.tmp.epidemy.piece = .get_obj_index(9607);
.tmp.epidemy.chocolatesVnumsList = .List().add(18078, 27110, 50042); //шоколадки чёрные 18078 27110 50042
.tmp.epidemy.ashVnum = 39002; //пепел 39002
.tmp.epidemy.roseVnum = 204; //роза   /*204 (rose black flower роза черная цветок)*/
.tmp.epidemy.pitVnum = 3010;
.tmp.epidemy.darkTempleVnum = 3072;
.tmp.epidemy.Demon = .get_mob_index(762);
.tmp.epidemy.Fiend = .get_mob_index(763);

    this = .tmp.epidemy;

    infect = function(mob) {
        this = .tmp.epidemy;

        //всё равно заболеет, заносим в список
        if(mob.epidemy==null)
            mob.epidemy = .Map();
        mob.epidemy.infected = true;

        infected.push_back(mob);

        mob = setInfectedTriggers(mob);
    };
    transform = function(mob) {
        this = .tmp.epidemy;
        //тёмные силы победили! УРА!
        //выворачиваем зверюгу наизнанку
        mob = evert(mob);
        mob = setSickTriggers(mob);
        clearPlan(mob);
    };
    getVictims = function(mob) {
        var count,i,l,vict;
        var result;

        result = .List();
        for(vict in mob.in_room.ppl) {
            if(vict==mob) continue;
            if(!vict.is_npc()) continue;
            if(vict.epidemy!=null) continue;

            if(vict.size <= mob.size //малышей кусь
                || (vict.leader!=null && vict.leader.pet==vict)) { //петов кусь
                result.push_back(vict);
            }
        }
        return result;
    };
    evert = function(mob) {
        this = .tmp.epidemy;
        var match;

        var long_descr;
        var enName;
        var regexp;

        var short_descr;
        var description;

        var name;
        var nameList;
        long_descr = 'Вывернутое наизнанку существо {D#runame{x {Y(#enname{Y) ходит тут задом наперед.\n';
        description = 'Отвратительное существо, вывернутое внутренностями наружу (несомненно какой-то\n' +
            '{Dтемной{x магией), {D#runame{x ходит здесь задом наперед. Лучше держаться\n' +
            'от ЭТОГО подальше, чтоб не укусило (страшно представить каким местом).\n' +
            'Из черных глаз существа вырываются еле заметные языки феолетово-черного пламени.\n\n';

        short_descr = reverseStr(mob.seeName(mob));

        regexp = ' \\((' + mob.name.replace(' ','|') + ')\\) ';
        match = mob.long_descr.matchGroups(regexp);

        if(match.size()) {
            long_descr = long_descr.replace('#enname', '{D'+reverseStr(match.back())+'{x');
        } else {
            long_descr = long_descr.replace('\{Y\(#enname\{Y\) ','{Y');
        }

        nameList = ((short_descr+' '+reverseStr(mob.name)).split(' ')).sort().unique();

        name = '';
        var i; var size;
        size = nameList.size();
        for(i=1;i<=size;i=i+1) {
            name = name+nameList.front();
            nameList.pop_front();
            if(i<size)
                name = name + ' ';
        }

        long_descr = long_descr.replace('#runame',short_descr);
        description = description.replace('#runame',short_descr);

        mob.recho("{DТёмные силы{x выворачивают %1$C4 наизнанку, превращая в {D"+short_descr+"{x. Фууууууу!", mob);
        // меняем описания, и сохраняем старые для выздоравливания.
        mob.epidemy.long_descr = mob.long_descr;
        mob.long_descr = long_descr;

        mob.epidemy.short_descr = mob.short_descr;
        mob.short_descr = '{D'+short_descr+'{x';

        mob.epidemy.description = mob.description;
        mob.description = description;

        mob.epidemy.name = mob.name;
        mob.name = name;

        mob.epidemy.alignment = mob.alignment;
        mob.alignment = -1000;

        return mob;
    };
    reverseStr = function(str) {
        var newStr;
        var alfa;
        var i;

        newStr = '';
        str = str.stripColour();
        for( i=0; i<80; i=i+1) {
            alfa = str.substr(i,1).toLower();
            if(alfa.match('[- йуёеъыаоэяиью]{1}|^$') && newStr.match('^[ьъ]')) {
                newStr = newStr.substr(1);
            }

            if(alfa=='')
                break;

            newStr = alfa + newStr;
        }

        return newStr;
    };
    heal = function(mob) {
        this = .tmp.epidemy;

        plan_cancel(mob);

        //будем сохранять и востанавливать, ибо мало ли кто во что был рестрингнут.
        if(mob.epidemy.name!=null) {
            mob.name = mob.epidemy.name;
            mob.short_descr = mob.epidemy.short_descr;
            mob.long_descr = mob.epidemy.long_descr;
            mob.description = mob.epidemy.description;
            mob.alignment = mob.epidemy.alignment;
        }

        mob.postSpec = null;
        mob.onGreet = null;
        mob.onEntry = null;
        mob.onLeave = null;
        mob.onSpell = null;
        mob.onDeath = null;
        mob.onExtract = null;
        mob.epidemy = null;

        //выпиливаем из списка зараженных
        infected.sub(mob);

        mob.recho("%1$^C1 выглядит здоров%1$Gым|ым|ой!", mob);
    };
    healall = function() {
        this = .tmp.epidemy;

        var infectedListClon;
        infectedListClon = infected.clone();

        for(sick in infectedListClon) {
            heal(sick);
        }
    };
    show = function(ch){
        this = .tmp.epidemy;
        infected.forEach(function(char){
            var plan;
            plan = '';
            if(epidemy.plan!=null && epidemy.plan>=1)
                plan = '->'+epidemy.plan_room.name+'('+epidemy.plan_room.vnum+')';
            char.ptc(char.seeName(this)+'->'+in_room.areaname+':'+in_room.name+'('+in_room.vnum+')'+plan+'\n');
        },ch);
    };
    plan_cancel = function(mob) {
        this = .tmp.epidemy;

        var total, city;
        var i, l, m;

        city = mob.in_room.areaname;

        l = infected.clone();
        total = l.size();

        for( i=1 ; i<=total ; i=i+1 ) {
            m = l.back();
            if(m.dead) {
                infected.sub(m);
                continue;
            } else if(m.in_room.areaname==city) {
                clearPlan(m);
            }
            l.pop_back();
        }

    };
    clearPlan = function(mob){
        mob.epidemy.plan = null;
        clearGPS(mob);
    };
    clearGPS = function(mob){
        mob.epidemy.plan_room = null;
        mob.epidemy.plan_waypoint = null;
        mob.epidemy.plan_nextroom = null;
        mob.epidemy.plan_way = null;
    };
    plan_check = function(mob) {
        this = .tmp.epidemy;

        var result;
        var total, city, room;
        var i,mlist,m,icount,fidovnum;
        var planG, planD;
        planG = true; planD = true;
        city = mob.in_room.areaname;
        room = mob.in_room;
        result = 0;

        /*
        * 0 - ты не последний зараженный
        * 1 - все заражены - собираемся до кучи
        * 2 - ты в куче, ждем остальных
        * 3 - я последний - вызываем "КРАКЕНА"
        */
        if(mob.epidemy.plan_room==null && mob.epidemy.plan==null) {

            mlist = .tmp.epidemy.infected.clone();
            total = mlist.size();
            //заражены должны быть все spec_fido, зараженных должно быть не меньше 13 на город
            icount = 0; //зараженных в городе
            for( i=1 ; i<=total ; i=i+1 ) {
                m = mlist.back();
                mlist.pop_back();
                if(m.dead) {
                    .tmp.epidemy.infected.sub(m);
                    continue;
                }
                if(!m.online || (m.leader!=null && m.leader.pet==m)) {
                    continue;
                }
                //тварь в нашем городе
                if (m.in_room.areaname == city){
                    icount=icount+1;
                    //фидо-лайк-тварь (их и будем проверять)
                    if(m.pIndexData.spec_fun == 'spec_fido') {
                        fidovnum = m.pIndexData.vnum;
                    }
                }
            }

            //должны быть заражены все fido-like, зараженных не меньше 13
            if(fidovnum!=null && icount >= 13 ) {

                mlist = .get_mob_index(fidovnum).instances.clone();

                result = 1;
                total = mlist.size();
                //все ли spec_fido в городе заражены
                for( i=1 ; i<=total ; i=i+1 ) {
                    m = mlist.back();
                    //тварь в нашем городе, но не инфицирована
                    if(m.in_room.areaname==city && m.epidemy==null){
                        planG = false; planD = false; result = 0;
                    }
                    mlist.pop_back();
                }

                mlist = .tmp.epidemy.infected.clone();
                total = mlist.size();
                for( i=1 ; i<=total ; i=i+1 ) {
                    m = mlist.back();
                    if(m.in_room.areaname==city && m.leader==null) {
                        clearGPS(m);
                        if(planG) {
                            //если планГ утвержден, прописываем всем в городе
                            m.epidemy.plan = 1;
                            m.epidemy.plan_room = room;
                        } else {
                            //ни у кого нет плана
                            m.epidemy.plan = 0;
                        }
                    }
                    mlist.pop_back();
                }
                //}
            } else {
                planG = false; planD = false;
            }
        }

        //если план Д еще не отменился, проверим...
        if(planD) {
            if(mob.in_room == mob.epidemy.plan_room) {
                result = 2;
            } else {
                result = 1;
                planD = false;
            }
            icount = 0;
            mlist = .tmp.epidemy.infected.clone();
            total = mlist.size();
            for( i=1 ; i<=total ; i=i+1 ) {
                m = mlist.back();
                if(m.in_room.areaname==city && m.in_room!=room){
                    planD = false;
                }

                if(planD)
                    icount=icount+1;

                mlist.pop_back();
            }

            //если планД утвержден, назначем ответственного за геноцид
            if(planD && icount>=13) {
                result = 3;
            }
        }

        return result;
    };
    explode_in_room = function(room) {
        var l,i,c,m;
        var ash;
        //try {
        room.ppl.forEach( function(){ act('Отвратительные существа вспыхивают темно-фиолетовым пламенем...');} );

        l = .tmp.epidemy.infected.clone();
        c = l.size();
        for(i=0;i<c;i=i+1){
            m = l.back();
            if(m.in_room==room && m.is_npc()){
                ash = .get_obj_index(.tmp.epidemy.ashVnum).create();
                ash.obj_to_room(room);
                ash.timer = 5;
                ash.description = 'Горсть пепла (ash) останков '+m.seeName(m,2)+'{G лежит у твоих ног.{x';

                m.extract(true);
            }
            l.pop_back();
        }
        /*} catch(e) {
            .get_char_world('miyamoto').ptc("epidemy.explode_in_room: " + e);
        }*/
    };

    fillEmotes = function(){
        this = .tmp.epidemy;

        //массивы социалов для зараженных
        emoteArray = .Array();
        emoteArray[0] = 'bounce self';  emoteArray[1] = 'burp self';
        emoteArray[2] = 'burp';         emoteArray[3] = 'confused';
        emoteArray[4] = 'conspire';     emoteArray[5] = 'cough';
        emoteArray[6] = 'fart';         emoteArray[7] = 'glare';
        emoteArray[8] = 'grimace';      emoteArray[9] = 'growl';
        emoteArray[10] = 'lick self';   emoteArray[11] = 'moan';
        emoteArray[12] = 'nail self';   emoteArray[13] = 'puke';
        emoteArray[14] = 'stagger';     emoteArray[15] = 'slobber';
        emoteArray[16] = 'twitch';      emoteArray[17] = 'wince';
        emoteArray[18] = 'fume';        emoteArray[19] = 'flinch';
        emoteArray[20] = 'rub self';    emoteArray[21] = 'sneeze';

        emoteTargArray = .Array();
        emoteTargArray[0] = "puke";
        emoteTargArray[1] = "stagger";
        emoteTargArray[2] = "growl";
    };
    fillTriggers = function () {
        this = .tmp.epidemy;

        if(triggers == null)
            triggers = .Map();

        triggers.infectedPostSpec = function(){
            if(.chance(1)) {
            .tmp.epidemy.transform(this);
            } else if(.chance(5)) {
                act("Ты корчишься в мучениях сопротивляясь {Dтёмным силам{x внутри себя!");
                recho("%1$^C1 дрожит и корчится сопротивляясь {Dтёмным силам{x внутри себя!", this);
            }
        };
        triggers.sickPostSpec = function () {
            try {
                if(dead) return;

                if(epidemy==null && !dead) throw('NO epidemy Map\n');

                if(epidemy.victims==null) {
                    epidemy.victims = .tmp.epidemy.getVictims(this);
                }
                if(epidemy.plan != null && epidemy.plan >= 1 && epidemy.plan_room==null) {
                    epidemy.plan = null;
                }

                if(epidemy.plan == null) {
                    epidemy.plan = .tmp.epidemy.plan_check(this);
                }

                if(epidemy.plan == 2 && epidemy.plan_room!=in_room) {
                    epidemy.plan = 1;
                }
                if(epidemy.plan == 1 && epidemy.plan_room==in_room) {
                    epidemy.plan = 2;
                }

                if(epidemy.plan == 3) {
                    //бывает что какая-то зверюга убегает в последний момент
                    epidemy.plan = .tmp.epidemy.plan_check(this);
                    //и если план без изменений
                    if(epidemy.plan == 3) {
                        var demon_room;

                        demon_room = in_room;
                        //взорвать всех зверюг в комнате
                    .tmp.epidemy.explode_in_room(demon_room);
                        //вызывать демона
                    .tmp.epidemy.get_one_demon(demon_room);
                        return;
                    }
                }

                //собака-кусака!
                if(epidemy.victims.size() && .chance(10)) {
                    //кусаем если есть кого
                    var vict;
                    vict = epidemy.victims.random();
                    if(vict.dead || vict.in_room!=in_room || vict.epidemy!=null){
                        //изчез куда-то гад!!!
                        epidemy.victims = null;
                    } else {
                        /*---некотролируемая эпидемия начинается здесь---*/
                        act("Повинуясь {Dтёмным силам{x внутри себя, ты кусаешь %1$C2!", vict);
                        vict.act("Повинуясь {Dтёмным силам{x внутри себя, %1$C1 кусает тебя.{/Частичка {Dтемных сил{x проникает в тебя!", this);
                        rvecho(vict,"%1$^C1, повинуясь {Dтёмным силам{x внутри себя, кусает %2$C4.{/Частичка {Dтёмных сил{x проникает в %2$C4!", this, vict);
                        vict.postSpec = function(){if(.chance(10)) .tmp.epidemy.infect(this);};
                        /*----------------------------------------------*/
                        epidemy.victims.sub(vict);
                    }
                    return;
                }

                //собака - гуляка!
                /*plan:
                * 0 - ты не последний зараженный
                * 1 - все заражены - собираемся до кучи
                * 2 - ты в куче, ждем остальных
                * 3 - я последний - вызываем "КРАКЕНА"
                */
                if(epidemy.plan==1 && .chance(50)) {
                    if(epidemy.plan_room==null)
                        throw('собака-гуляка '+name+':plan_room==null;in_room:'+in_room.name+'('+in_room.vnum+')\n');

                    if(epidemy.plan_way==null) {
                        if(!epidemy.plan_room.isCommon()) {
                            epidemy.plan = null;
                            epidemy.plan_room = null;
                            //return;
                        } else {
                            //ищем путь
                            interpret('ponder');
                            epidemy.plan_way = .tmp.epidemy.find_way(this,epidemy.plan_room);
                            if(epidemy.plan_way.size()>0){
                                epidemy.plan_waypoint = in_room;
                                return;
                            } else {
                                // беда! пустой маршрут
                            }
                        }
                    } else if(epidemy.plan_nextroom == null) {
                    .tmp.epidemy.make_your_move(this);
                    } else if (epidemy.plan_waypoint!=in_room) { //сбились с маршрута
                        epidemy.plan_waypoint = null;
                        epidemy.plan_nextroom = null;
                        epidemy.plan_way = null;
                    } else { //маршрут есть и мы с него не сбились
                        if(.chance(20)) {
                            var exitDoor;
                            exitDoor = in_room.doorTo(epidemy.plan_nextroom);

                            if(in_room.getExitFlags(exitDoor) & .tables.exit_flags.closed) {

                                if(.chanceOneOf(4))
                                {
                                    recho('%1$^C1 бьётся головой в %2$N4. Закрыто.',this,in_room.exitShortDescr(exitDoor));
                                }
                            else if(.chanceOneOf(3))
                                {
                                    recho('%1$^C1 жалобно скулит и скребётся в %2$N4. Тщетно.',this, in_room.exitShortDescr(exitDoor));
                                }
                            else if (.chanceOneOf(2))
                                {
                                    var ppllist, sucker;
                                    ppllist = in_room.ppl.clone();
                                    ppllist.sub(this);
                                    if(ppllist.size()>0) {
                                        sucker = ppllist.random();
                                        sucker.recho('%1$^C1 садится перед %2$N5, и жалобно смотрит в глаза %3$C3.',this, in_room.exitShortDescr(exitDoor), sucker);
                                        sucker.act('%1$^C1 садится перед %2$N5, и жалобно смотрит тебе в глаза.',this, in_room.exitShortDescr(exitDoor));
                                    } else {
                                        recho('%1$^C1 садится перед %2$N5, и жалобно завывает.',this, in_room.exitShortDescr(exitDoor));
                                    }
                                }
                            else
                                {
                                    recho('На мгновение в глазах %1$C1 вспыхивает искра интеллекта.',this);
                                    interpret('open '+in_room.doorName(exitDoor));
                                }

                                return;
                            } else {
                                if(.chanceOneOf(3)) {
                                    recho("%1$^C1 ходит кругами и нюхает следы. Этим что, можно ещё и нюхать?!",this);
                                } else if(.chanceOneOf(2)) {
                                    in_room.ppl.forEach(function (mob) {act("%1$^C1 принюхивается. Ты и представить себе не мог%2$Gло||ла, что ЭТИМ можно нюхать!",mob,this);},this);

                                } else {

                                .tmp.epidemy.make_your_move(this);

                                }
                                return;
                            }


                        }
                    }
                }

                //собака-кривляка!
                if(.chance(5)) {
                    //спамим всякими социалами
                    if (in_room.ppl.size()<2)
                        return;

                    var numba,temotes,emotes;
                    emotes = .tmp.epidemy.emoteArray.keys.size();
                    temotes = .tmp.epidemy.emoteTargArray.keys.size();
                    numba = .number_range(0, (temotes+emotes-1));

                    if (numba > (emotes-1)) {
                        var target;
                        var str;
                        numba = numba - emotes;

                        if(.tmp.epidemy.emoteTargArray[numba]==null)
                        throw 'epidemy: mob.onSpec: нет такой emoteTargArray';

                        for(target=in_room.ppl.random();target==this;target=in_room.ppl.random()) {}

                        str = .tmp.epidemy.emoteTargArray[numba] + ' ' + target.name;
                        interpret(str);
                    } else {
                        interpret(.tmp.epidemy.emoteArray[numba]);
                    }
                    return;
                }
            } catch(e){
                var me;
                me = .get_char_world('miyamoto');
                if(me!=null)
                    me.ptc('epidemy.postSpec:'+e);
            }
        };

        /*onSpell(ch, spell, before) - ch пытается колдовать на нас заклинание spell,
        где spell - англ название умения. Вызывается дважды, причем before будет равно true перед кастом,
        и false - после каста. Если вернуть true из первого вызова, то заклинание выполнено не будет.
        Если вернуть true из второго вызова, то отрицательной реакции на атакующее заклинание не последует.  */
        triggers.infectedOnSpell = function(ch,spell,before) {
            //dispel evil
            if(before){
                if(spell == 'dispel evil' || spell == 'heal' || spell == 'superior heal') {
                    recho("%1$^C1 одной стороной чихает, другой выпускает {Dтёмное облочко{x...", this);
                    return true;
                }
            } else {
                if(spell == 'dispel evil' || spell == 'heal' || spell == 'superior heal') {
                .tmp.epidemy.heal(this);
                    return true;
                }
            }
            //ray of truth
        };
        triggers.sickOnSpell = function(ch,spell,before) {
            //dispel evil
            if(before){
                if(spell == 'dispel evil' || spell == 'ray of truth'
                    || spell == 'wrath' || spell == 'banishment') {
                    recho("%1$^C1 одной стороной чихает, другой выпускает {Dтёмное облочко{x...", this);
                    return true;
                }
            } else {
                if(spell == 'dispel evil' || spell == 'ray of truth'
                    || spell == 'wrath' || spell == 'banishment') {
                .tmp.epidemy.heal(this);
                    return true;
                }
            }
            //ray of truth
        };

        //onDeath(ch) - ch убил нас. если вернуть true, мы не умрем и останемся стоять
        triggers.infectedOnDeath = function(ch) {
            //выпиливаемся из списка
            .tmp.epidemy.infected.sub(this);
        };
        triggers.infectedOnExtract = function(count) {
            //выпиливаемся из списка
            .tmp.epidemy.infected.sub(this);
        };

        //onLeave(ch, from_room, movetype) - ch только что вышел из нашей комнаты
        triggers.sickOnLeave = function(ch, from_room, movetype) {
            epidemy.victims = null;
        };

        //onEntry() - мы вошли в какую-то комнату
        triggers.sickOnEntry = function() {
            epidemy.victims = null;
        };

        //onGreet(ch) - ch вошел в нашу комнату
        triggers.sickOnGreet = function(ch) {
            epidemy.victims = null;
        };

        //onDeath(ch) - ch убил нас. если вернуть true, мы не умрем и останемся стоять
        triggers.sickOnDeath = function(ch) {
            //выпиливаемся из списка
        .tmp.epidemy.infected.sub(this);

            //отменяем план
            if(epidemy.plan!=null)
                .tmp.epidemy.plan_cancel(this);

            //вылупляем импа
            if(.tmp.epidemy.imp_list!=null && .tmp.epidemy.imp_list.size()>0
                && .tmp.epidemy.initImp!=null && .tmp.epidemy.imp_list.has(pIndexData)) {
                var imp;
                imp = .tmp.epidemy.imp_list.random().create();
            .tmp.epidemy.initImp(imp);
                imp.char_to_room(ch.in_room);
                ch.in_room.echo('Из останков %1$C1, весь в кишках и ошметках, вылезает %2$C1.',this,imp);
            }
        };

    };
    fillInfected = function() {
        var i, result;

        result = .List();

        for (i = .char_list; i != null; i = i.next) {
            if (i.is_npc() && i.epidemy != null && (i.epidemy.infected!=null && i.epidemy.infected==true) && !i.dead) {
                result.push_back(i);
            }
        }
        return result;
    };

    setInfectedTriggers = function(mob) {
        mob.onSpec = null;

        mob.postSpec = .tmp.epidemy.triggers.infectedPostSpec;
        mob.onSpell = .tmp.epidemy.triggers.infectedOnSpell;
        mob.onDeath = .tmp.epidemy.triggers.infectedOnDeath;
        mob.onExtract = .tmp.epidemy.triggers.infectedOnExtract;

        return mob;
    };
    setSickTriggers = function(mob) {
        mob.postSpec = .tmp.epidemy.triggers.sickPostSpec;
        mob.onSpell = .tmp.epidemy.triggers.sickOnSpell;
        mob.onLeave = .tmp.epidemy.triggers.sickOnLeave;
        mob.onEntry = .tmp.epidemy.triggers.sickOnEntry;
        mob.onGreet = .tmp.epidemy.triggers.sickOnGreet;
        mob.onDeath = .tmp.epidemy.triggers.sickOnDeath;

        return mob;
    };

    fillTriggers();
    fillEmotes();
    //список зараженных
    infected = fillInfected();

    //перепрошивка зараженных из списка свежими тригерами
    infected.forEach(function () {
        epidemy.plan_way = null;
        epidemy.plan_waypoint = null;
        epidemy.plan_nextroom = null;
        this = .tmp.epidemy.setInfectedTriggers(this);
        if(epidemy.name!=null)
            this = .tmp.epidemy.setSickTriggers(this);

    });
})

//Name: [fido dog зверюга] Vnum: [3062] Spec fun: [spec_fido] Size: [small]
//Name: [alley cat feline кот] Vnum: [9543] Size: [small]
//Name: [vulture стервятник] Vnum: [9544] Spec fun: [spec_fido] Size: [small]
//eval looking4fido = function(sf,ch) {for(i=.char_list;i!=null;i=i.next) {if(i.pc!=null) {continue;} if(i.pIndexData.spec_fun==sf) ch.ptc(''+i.pIndexData.vnum+i.name+'\n');}}

