epidemyInit = function() {
    var fillEmotes, fillTriggers, fillInfected;
	if (.tmp.epidemy == null)
        .tmp.epidemy = .Map();

	this = .tmp.epidemy;

	infect = function(mob) {
		//всё равно заболеет, заносим в список
		mob.epidemy = .Map();

		.tmp.epidemy.infected.push_back(mob);

		mob = .tmp.epidemy.addInfectedTriggers(mob);

	};
	addInfectedTriggers = function(mob) {
		mob.onSpec = .tmp.epidemy.triggers.infectedOnSpec;
		mob.onSpell = .tmp.epidemy.triggers.infectedOnSpell;
		mob.onDeath = .tmp.epidemy.triggers.infectedOnDeath;
		return mob;
	};
	addSickTriggers = function(mob) {
		mob.onSpec = .tmp.epidemy.triggers.sickOnSpec;
		mob.onLeave = .tmp.epidemy.triggers.sickOnLeave;
		mob.onEntry = .tmp.epidemy.triggers.sickOnEntry;
		mob.onGreet = .tmp.epidemy.triggers.sickOnGreet;
		mob.onDeath = .tmp.epidemy.triggers.sickOnDeath;

		return mob;
	};
	transform = function(mob) {
		//тёмные силы победили! УРА!

		//выворачиваем зверюгу наизнанку если она не пет
		//if(mob.leader==null)
		//хотя почему нет? выворачиваем всех...
		.tmp.epidemy.evert(mob);

		mob = .tmp.epidemy.addSickTriggers(mob);

		.tmp.epidemy.getVictims(mob, 'Init');

		// план G - все заражены, собраться всем в комнате
		// план D - все в одной комнате, вызываем "кракена"
		.tmp.epidemy.plan_check(mob);
	};
	getVictims = function(mob,text) {
		mob.epidemy.victims = .List();
		mob.in_room.ppl.forEach(function(mob){
			if(!(this == mob //себя не кусаю
					|| this.epidemy!=null //зараженных не кусаем
					|| !this.is_npc() //игроков не кусаем
					|| this.size > 1 //больших не кусаем
				)
				|| (this.is_npc() && this.leader!=null && this.leader.pet==this) //петов кусаем
			) {
				mob.epidemy.victims.push_back(this);
			}
		},mob);
	};
	evert = function(mob) {
		this = .tmp.epidemy;
		var match;

		var long_descr;
		var enName;
		var regexp;

		var short_descr;
		var description;

		var name;
		var nameList;
		long_descr = 'Вывернутое наизнанку существо {D#runame{x {Y(#enname{Y) ходит тут задом наперед.\n';
		description = 'Отвратительное существо, вывернутое внутренностями наружу (несомненно какой-то\n' +
			'{Dтемной{x магией), {D#runame{x ходит здесь задом наперед. Лучше держаться\n' +
			'от ЭТОГО подальше, чтоб не укусило (страшно представить каким местом).\n' +
			'Из черных глаз существа вырываются еле заметные языки феолетово-черного пламени.\n\n';

		short_descr = reverseStr(mob.seeName(mob));

		regexp = ' \\((' + mob.name.replace(' ','|') + ')\\) ';
		match = mob.long_descr.matchGroups(regexp);

		if(match.size()) {
			long_descr = long_descr.replace('#enname', '{D'+reverseStr(match.back())+'{x');
		} else {
			long_descr = long_descr.replace('(#enname) ','');
		}

		nameList = ((short_descr+' '+reverseStr(mob.name)).split(' ')).sort().unique();

		name = '';
		var i; var size;
		size = nameList.size();
		for(i=1;i<=size;i=i+1) {
			name = name+nameList.front();
			nameList.pop_front();
			if(i<size)
				name = name + ' ';
		}

		long_descr = long_descr.replace('#runame',short_descr);
		description = description.replace('#runame',short_descr);

		mob.recho("{DТёмные силы{x выворачивают %1$C4 наизнанку, превращая в {D"+short_descr+"{x. Фууууууу!", mob);
		// меняем описания, и сохраняем старые для выздоравливания.
		mob.epidemy.long_descr = mob.long_descr;
		mob.long_descr = long_descr;

		mob.epidemy.short_descr = mob.short_descr;
		mob.short_descr = '{D'+short_descr+'{x';

		mob.epidemy.description = mob.description;
		mob.description = description;
		//2do: хорошо бы надевать на петов ошейник с именем

		mob.epidemy.name = mob.name;
		mob.name = name;
	};
	reverseStr = function(str) {
		var newStr;
		var alfa;
		var i;

		newStr = '';

		for( i=0; i<100; i=i+1) {
			alfa = str.substr(i,1);
			if(alfa=='')
				break;

			newStr = alfa + newStr;
		}

		return newStr.toLower();
	};
	heal = function(mob) {
		//будем сохранять и востанавливать, ибо мало ли кто во что был рестрингнут.
		if(mob.epidemy.name!=null) {
			mob.name = mob.epidemy.name;
			mob.short_descr = mob.epidemy.short_descr;
			mob.long_descr = mob.epidemy.long_descr;
			mob.description = mob.epidemy.description;
		}

		mob.onSpec = null;
		mob.onGreet = null;
		mob.onEntry = null;
		mob.onLeave = null;
		mob.onSpell = null;
		mob.onDeath = null;
		mob.epidemy = null;

		//выпиливаем из списка зараженных
	.tmp.epidemy.infected.sub(mob);

		mob.recho("%1$^C1 выглядит здоров%1$Gым|ым|ой!", mob);
	};
	healall = function() {
	.tmp.epidemy.infected.forEach(function(){.tmp.epidemy.heal(this);});
	};
	show = function(ch){
		if(ch==null)
			ch=.get_char_world('miyamoto');

	.tmp.epidemy.infected.forEach(function(char){
			var plan;
			plan = '';
			if(epidemy.plan!=null)
				plan = '->'+.get_room_index(epidemy.plan_room).name+'('+epidemy.plan_room+')';
			char.ptc(in_room.areaname+':'+in_room.name+'('+in_room.vnum+')'+':'+char.seeName(this)+plan+'\n');
		},ch);
	};
	plan_cancel = function(mob) {
		//test
		//.tmp.epidemy.me.ptc('epidemy: plan_cancel()\n');

		var total, city;
		var i, l, m;

		city = mob.in_room.areaname;

		l = .tmp.epidemy.infected.clone();
		total = l.size();

		for( i=1 ; i<=total ; i=i+1 ) {
			m = l.back();
			if(m.in_room.areaname==city) {
				m.epidemy.plan = null;
				m.epidemy.plan_room = null;
				m.epidemy.plan_waypoint = null;
				m.epidemy.plan_nextroom = null;
				m.epidemy.plan_way = null;
			}
			l.pop_back();
		}

	};
	plan_check = function(mob) {
		var total, city, room;
		var i,mlist,m,icount;
		var planG, planD;
		planG = true; planD = true;
        city = mob.in_room.areaname;
        room = mob.in_room.vnum;

		if(mob.epidemy.plan==null) {
		    .tmp.epidemy.plan_cancel(mob);

            mlist = mob.pIndexData.instances.clone();
            // если тварей меньше 10 то нечего и собираться
            if (mlist.size() < 10) return;

            total = mlist.size();
            for( i=1 ; i<=total ; i=i+1 ) {
                m = mlist.back();
                //тварь в нашем городе, но не инфицирована
                if(m.in_room.areaname==city && m.epidemy==null)
                    planG = false;
                mlist.pop_back();
            }

            //если планГ утвержден, и он еще не прописан - прописываем
            if(planG) {
                //test
                //.tmp.epidemy.me.ptc('EPIDEMY: PLAN G!!!\n');

                mlist = .tmp.epidemy.infected.clone();
                total = mlist.size();
                for( i=1 ; i<=total ; i=i+1 ) {
                    m = mlist.back();
                    if(m.in_room.areaname==city && m.leader==null) {
                        m.epidemy.plan = 1;
                        m.epidemy.plan_room = room;
                    }
                    mlist.pop_back();
                }
            }
        }
        if(mob.epidemy.plan==1) {
		    icount = 0;
            mlist = .tmp.epidemy.infected.clone();
            total = mlist.size();
            for( i=1 ; i<=total ; i=i+1 ) {
                m = mlist.back();
                if(m.in_room.areaname==city && m.in_room.vnum!=room)
                    planD = false;

                if(planD)
                    icount=icount+1;

                mlist.pop_back();
            }

            //если планД утвержден, назначем ответственного за геноцид
            if(planD && icount>=10) {
                //test
                //.tmp.epidemy.me.ptc('EPIDEMY: PLAN D!!!\n');

                mob.epidemy.plan = 2;
            }
        }

	};
	explode_in_room = function(room) {
        var l,i,c,m;
        var ash;
		room.ppl.forEach( function(){ act('Отвратительные существа вспыхивают темно-фиолетовым пламенем...');} );
		
		l = .tmp.epidemy.infected.clone();
		c = l.size();
		for(i=0;i<c;i=i+1){
		    m = l.back();
		    if(m.in_room==room && m.is_npc()){
                ash = .get_obj_index(.tmp.epidemy.ashVnum).create();
                ash.obj_to_room(room);
                ash.timer = 5;
                ash.description = 'Горсть пепла (ash) останков '+m.seeName(m,2)+'{G лежит у твоих ног.{x';

		        m.extract(true);
		    }
            l.pop_back();
		}
	};

    fillEmotes = function(){
    	this = .tmp.epidemy;

        //массивы социалов для зараженных
        emoteArray = .Array();
        emoteArray[0] = 'bounce self';  emoteArray[1] = 'burp self';
        emoteArray[2] = 'burp';         emoteArray[3] = 'confused';
        emoteArray[4] = 'conspire';     emoteArray[5] = 'cough';
        emoteArray[6] = 'fart';         emoteArray[7] = 'glare';
        emoteArray[8] = 'grimace';      emoteArray[9] = 'growl';
        emoteArray[10] = 'lick self';   emoteArray[11] = 'moan';
        emoteArray[12] = 'nail self';   emoteArray[13] = 'puke';
        emoteArray[14] = 'stagger';     emoteArray[15] = 'slobber';
        emoteArray[16] = 'twitch';      emoteArray[17] = 'wince';
        emoteArray[18] = 'fume';        emoteArray[19] = 'flinch';
        emoteArray[20] = 'rub self';    emoteArray[21] = 'sneeze';

        emoteTargArray = .Array();
        emoteTargArray[0] = "puke";
        emoteTargArray[1] = "stagger";
        emoteTargArray[2] = "growl";
	};
    fillTriggers = function () {
        this = .tmp.epidemy;

        if(triggers == null)
    		triggers = .Map();

		triggers.infectedOnSpec = function(){
			if(.chance(1)) {
			.tmp.epidemy.transform(this);
			} else if(.chance(5)) {
				act("Ты корчишься в мучениях сопротивляясь {Dтёмным силам{x внутри себя!");
				recho("%1$^C1 дрожит и корчится сопротивляясь {Dтёмным силам{x внутри себя!", this);
			}
		};

        triggers.infectedOnSpell = function(ch,spell,before) {
			//dispel evil
			if(before && spell == 15) {
				recho("%1$^C1 одной стороной чихает, другой выпускает {Dтёмное облочко{x...", this);
				.tmp.epidemy.heal(this);
				return true;
			}

			//ray of truth
		};

		//onDeath(ch) - ch убил нас. если вернуть true, мы не умрем и останемся стоять
        triggers.infectedOnDeath = function(ch) {
			//выпиливаемся из списка
		.tmp.epidemy.infected.sub(this);
		};
        triggers.infectedOnExtract = function(count) {
			//выпиливаемся из списка
		.	tmp.epidemy.infected.sub(this);
		};

        triggers.sickOnSpec = function () {
			if(epidemy.victims.size() && .chance(10)) {
				//кусаем если есть кого
				var vict;
				vict = epidemy.victims.random();
				if(vict.in_room!=in_room || vict.epidemy!=null){
				.tmp.epidemy.getVictims(this,'onSpec');
				} else {
					/*---некотролируемая эпидемия начинается здесь---*/
					act("Повинуясь {Dтёмным силам{x внутри себя, ты кусаешь %1$C2!", vict);
					vict.act("Повинуясь {Dтёмным силам{x внутри себя, %1$C1 кусает тебя.{/Частичка {Dтемных сил{x проникает в тебя!", this);
					rvecho(vict,"%1$^C1, повинуясь {Dтёмным силам{x внутри себя, кусает %2$C4.{/Частичка {Dтёмных сил{x проникает в %2$C4!", this, vict);
					vict.onSpec = function(){if(.chance(10)) .tmp.epidemy.infect(this);};
					/*----------------------------------------------*/
				.tmp.epidemy.getVictims(this,'onSpec2');
				}
			} else if(epidemy.plan == 2) {
				var demon_room;
				demon_room = in_room;
				//взорвать всех зверюг в комнате
				.tmp.epidemy.explode_in_room(demon_room);
				//вызывать демона
				.tmp.epidemy.get_one_demon(demon_room);
			} else if(.chance(50) && (epidemy.plan == 1 && in_room.vnum!=epidemy.plan_room) ) { //&& .chance(5)
				// нет маршрута, или сместились в процессе следования
				if(epidemy.plan_way==null || epidemy.plan_waypoint!=in_room) {
					//ищем путь
					var sectorsDeny;
					interpret('ponder');
					sectorsDeny = 0;
					/*
					Руфина говорит тебе 'а вообще я добавила .set_bit_number'
					Руфина говорит тебе 'сектор - это номер, а если хочется получить битовую маску, надо установить бит с этим номером, а не просто логическое или делать'
					Руфина говорит тебе 'в общем что-то типа x=.set_bit_number(x, .tables.sector_table.air) , потом вода и тд'
*/
					// sectorsDeny = .tables.sector_table.water_swim;
					// sectorsDeny = .set_bit(sectorsDeny, .tables.sector_table.air);
					epidemy.plan_way = in_room.traverseTo(.get_room_index(epidemy.plan_room), this, 0, sectorsDeny);
					epidemy.plan_waypoint = in_room;
				} else {
					//маршрут есть, мы еще не на месте
					if(epidemy.plan_nextroom==null) {
						//test
						// interpret('say куда б податься? (идти мне, кстати, еще ' + epidemy.plan_way.size() + ' комнат)');
						if(.chance(20)) {
							if(.chanceOneOf(2)) {
								//нюхаем
								in_room.ppl.forEach(function (mob) {act("%1$^C1 принюхивается. Ты и представить себе не мог%2$G||ло|ла, что ЭТИМ можно нюхать!",mob,this);},this);
								epidemy.plan_nextroom = epidemy.plan_way.front();
								epidemy.plan_way.pop_front();
							} else {
								interpret('itch');
							}

						}
					} else {
						//унюхали - делаем шаг
						if(.chance(20)){
							//test
							//interpret('say ну, пойду в '+epidemy.plan_nextroom.name+', а то мне еще шагать ' + epidemy.plan_way.size() + " комнат! (выход:"+in_room.doorTo(epidemy.plan_nextroom)+')');
							if(move_char(in_room.doorTo(epidemy.plan_nextroom))){
								//test
								//interpret('say вот, пришла в '+epidemy.plan_nextroom.name+'. ай да я!');
								epidemy.plan_waypoint = epidemy.plan_nextroom;
								epidemy.plan_nextroom = null;
								if(in_room.vnum = epidemy.plan_room && epidemy.plan_way.size()==0) {
								.tmp.epidemy.plan_check(this);
									epidemy.plan_way = null;
								}
							} else {
								//test
							//.tmp.epidemy.me.ptc('заблудилось '+name+' в '+in_room.name
							//		+ '(plan_room:'+epidemy.plan_room+' plan_waipoint:'+epidemy.plan_waypoint.vnum+epidemy.plan_waypoint.name+' plan_nextroom:'+epidemy.plan_nextroom.vnum+epidemy.plan_nextroom.name+')');

								interpret('bonk');
								//test
								interpret('say заблудилася я! ПА-МА-ГИ-ТЕ!!!');
								epidemy.plan_nextroom = null;
								epidemy.plan_way = null;
								epidemy.plan_waypoint = null;
							}

						}
					}
				}


			} else  {
				//спамим всякими социалами
				if (in_room.ppl.size()<2 || !.chance(5))
				return;

				var numba,temotes,emotes;
				emotes = .tmp.epidemy.emoteArray.keys.size();
				temotes = .tmp.epidemy.emoteTargArray.keys.size();
				numba = .number_range(0, (temotes+emotes-1));

				if (numba > (emotes-1)) {
					var target;
					var str;
					numba = numba - emotes;

					if(.tmp.epidemy.emoteTargArray[numba]==null)
					throw 'epidemy: mob.onSpec: нет такой emoteTargArray';

					for(target=in_room.ppl.random();target==this;target=in_room.ppl.random()) {}

					str = .tmp.epidemy.emoteTargArray[numba] + ' ' + target.name;
					interpret(str);
				} else {
					interpret(.tmp.epidemy.emoteArray[numba]);
				}
			}
		};

        //onLeave(ch, from_room, movetype) - ch только что вышел из нашей комнаты
		triggers.sickOnLeave = function(ch, from_room, movetype) {
            .tmp.epidemy.getVictims(this,'onLeave');
		};

		//onEntry() - мы вошли в какую-то комнату
        triggers.sickOnEntry = function() {
		.tmp.epidemy.getVictims(this,'onEntry');
		};

		//onGreet(ch) - ch вошел в нашу комнату
        triggers.sickOnGreet = function(ch) {
		.tmp.epidemy.getVictims(this,'onGreet');
		};

		//onDeath(ch) - ch убил нас. если вернуть true, мы не умрем и останемся стоять
        triggers.sickOnDeath = function(ch) {
			//выпиливаемся из списка
			.tmp.epidemy.infected.sub(this);

			//отменяем план
			if(epidemy.plan!=null)
				.tmp.epidemy.plan_cancel(this);
			//вылупляем импа
		};

    };
    fillInfected = function() {
		var i, result;

        result = .List();

		for (i = .char_list; i != null; i = i.next) {
			if (i.is_npc() && i.epidemy != null && !i.dead) {
				result.push_back(i);
			}
		}
		return result;
    };

    fillTriggers();
	fillEmotes();
    //список зараженных
    infected = fillInfected();


    //2do перепрошивка может не понадобиться если функции хранить в .tmp.epidemy
    //перепрошивка зараженных из списка
    infected.forEach(function () {
        epidemy.plan_way = null;
        epidemy.plan_waypoint = null;
        epidemy.plan_nextroom = null;
    	.tmp.epidemy.addInfectedTriggers(this);
        if(epidemy.long_descr != null)
            .tmp.epidemy.addSickTriggers(this);
    });
}

//Name: [fido dog зверюга] Vnum: [3062] Spec fun: [spec_fido] Size: [small]
//Name: [alley cat feline кот] Vnum: [9543] Size: [small]
//Name: [vulture стервятник] Vnum: [9544] Spec fun: [spec_fido] Size: [small]
//eval looking4fido = function(sf,ch) {for(i=.char_list;i!=null;i=i.next) {if(i.pc!=null) {continue;} if(i.pIndexData.spec_fun==sf) ch.ptc(''+i.pIndexData.vnum+i.name+'\n');}}

