.apply(function() {
//epidemyInit = function() {
    var fillEmotes, fillTriggers, fillInfected;
    if(.tmp.epidemy==null) .tmp.epidemy = .Map();
    if(.tmp.epidemy.infected==null) .tmp.epidemy.infected = .List();
    if(.tmp.epidemy.warlocks==null) .tmp.epidemy.warlocks = .List();
    if(.tmp.epidemy.books==null) .tmp.epidemy.books=.Array();
    if(.tmp.epidemy.demons==null) .tmp.epidemy.books=.List();

    //this = .tmp.epidemy;

.tmp.epidemy.bookkeeper = .get_mob_index(761);
.tmp.epidemy.necronomicon = .get_obj_index(732);
.tmp.epidemy.piece = .get_obj_index(9607);
.tmp.epidemy.chocolatesVnumsList = .List().add(18078, 27110, 50042); //шоколадки чёрные 18078 27110 50042
.tmp.epidemy.ashVnum = 39002; //пепел 39002
.tmp.epidemy.roseVnum = 204; //роза   /*204 (rose black flower роза черная цветок)*/
.tmp.epidemy.pitVnum = 3010;
.tmp.epidemy.darkTempleVnum = 3072;
.tmp.epidemy.Demon = .get_mob_index(762);
.tmp.epidemy.Fiend = .get_mob_index(763);

    this = .tmp.epidemy;

    infect = function(mob) {
        this = .tmp.epidemy;

        //всё равно заболеет, заносим в список
        if(mob.epidemy==null)
            mob.epidemy = .Map();
        mob.epidemy.infected = true;

        infected.push_back(mob);

        mob = setInfectedTriggers(mob);
    };
    transform = function(mob) {
        this = .tmp.epidemy;
        //тёмные силы победили! УРА!
        //выворачиваем зверюгу наизнанку
        mob = evert(mob);
        mob = setSickTriggers(mob);
        clearPlan(mob);
    };
    getVictims = function(mob) {
        var count,i,l,vict;
        var result;

        result = .List();
        for(vict in mob.in_room.ppl) {
            if(vict==mob) continue;
            if(!vict.is_npc()) continue;
            if(vict.epidemy!=null) continue;

            if(vict.size <= mob.size //малышей кусь
                || (vict.leader!=null && vict.leader.pet==vict)) { //петов кусь
                result.push_back(vict);
            }
        }
        return result;
    };
    evert = function(mob) {
        this = .tmp.epidemy;
        var match;

        var long_descr;
        var enName;
        var regexp;

        var short_descr;
        var description;

        var name;
        var nameList;
        long_descr = 'Вывернутое наизнанку существо {D#runame{x {Y(#enname{Y) ходит тут задом наперед.\n';
        description = 'Отвратительное существо, вывернутое внутренностями наружу (несомненно какой-то\n' +
            '{Dтемной{x магией), {D#runame{x ходит здесь задом наперед. Лучше держаться\n' +
            'от ЭТОГО подальше, чтоб не укусило (страшно представить каким местом).\n' +
            'Из черных глаз существа вырываются еле заметные языки феолетово-черного пламени.\n\n';

        short_descr = reverseStr(mob.seeName(mob));

        regexp = ' \\((' + mob.name.replace(' ','|') + ')\\) ';
        match = mob.long_descr.matchGroups(regexp);

        if(match.size()) {
            long_descr = long_descr.replace('#enname', '{D'+reverseStr(match.back())+'{x');
        } else {
            long_descr = long_descr.replace('\{Y\(#enname\{Y\) ','{Y');
        }

        nameList = ((short_descr+' '+reverseStr(mob.name)).split(' ')).sort().unique();

        name = '';
        var i; var size;
        size = nameList.size();
        for(i=1;i<=size;i=i+1) {
            name = name+nameList.front();
            nameList.pop_front();
            if(i<size)
                name = name + ' ';
        }

        long_descr = long_descr.replace('#runame',short_descr);
        description = description.replace('#runame',short_descr);

        mob.recho("{DТёмные силы{x выворачивают %1$C4 наизнанку, превращая в {D"+short_descr+"{x. Фууууууу!", mob);
        // меняем описания, и сохраняем старые для выздоравливания.
        mob.epidemy.long_descr = mob.long_descr;
        mob.long_descr = long_descr;

        mob.epidemy.short_descr = mob.short_descr;
        mob.short_descr = '{D'+short_descr+'{x';

        mob.epidemy.description = mob.description;
        mob.description = description;

        mob.epidemy.name = mob.name;
        mob.name = name;

        mob.epidemy.alignment = mob.alignment;
        mob.alignment = -1000;

        return mob;
    };
    reverseStr = function(str) {
        var newStr;
        var alfa;
        var i;

        newStr = '';
        str = str.stripColour();
        for( i=0; i<80; i=i+1) {
            alfa = str.substr(i,1).toLower();
            if(alfa.match('[- йуёеъыаоэяиью]{1}|^$') && newStr.match('^[ьъ]')) {
                newStr = newStr.substr(1);
            }

            if(alfa=='')
                break;

            newStr = alfa + newStr;
        }

        return newStr;
    };
    heal = function(mob) {
        this = .tmp.epidemy;

        plan_cancel(mob);

        //будем сохранять и востанавливать, ибо мало ли кто во что был рестрингнут.
        if(mob.epidemy.name!=null) {
            mob.name = mob.epidemy.name;
            mob.short_descr = mob.epidemy.short_descr;
            mob.long_descr = mob.epidemy.long_descr;
            mob.description = mob.epidemy.description;
            mob.alignment = mob.epidemy.alignment;
        }

        mob.postSpec = null;
        mob.onGreet = null;
        mob.onEntry = null;
        mob.onLeave = null;
        mob.onSpell = null;
        mob.onDeath = null;
        mob.onExtract = null;
        mob.epidemy = null;

        //выпиливаем из списка зараженных
        infected.sub(mob);

        mob.recho("%1$^C1 выглядит здоров%1$Gым|ым|ой!", mob);
    };
    healall = function() {
        this = .tmp.epidemy;

        var infectedListClon;
        infectedListClon = infected.clone();

        for(sick in infectedListClon) {
            heal(sick);
        }
    };
    show = function(ch){
        this = .tmp.epidemy;
        infected.forEach(function(char){
            var plan;
            plan = '';
            if(leader!=null && leader.pet==this)
                plan = '(pet)';
            else if(epidemy.plan!=null && epidemy.plan>=1)
                plan = '->'+epidemy.plan_room.name+'('+epidemy.plan_room.vnum+')';
            char.ptc(char.seeName(this)+'->'+in_room.areaname+':'+in_room.name+'('+in_room.vnum+')'+plan+'\n');
        },ch);
    };
    plan_cancel = function(mob) {
        this = .tmp.epidemy;

        var total, city;
        var i, l, m;

        city = mob.in_room.areaname;

        l = infected.clone();
        total = l.size();

        for( i=1 ; i<=total ; i=i+1 ) {
            m = l.back();
            if(m.dead) {
                infected.sub(m);
                continue;
            } else if(m.in_room.areaname==city) {
                clearPlan(m);
            }
            l.pop_back();
        }

    };
    clearPlan = function(mob){
        mob.epidemy.plan = null;
        clearGPS(mob);
    };
    clearGPS = function(mob){
        mob.epidemy.plan_room = null;
        mob.epidemy.plan_waypoint = null;
        mob.epidemy.plan_nextroom = null;
        mob.epidemy.plan_way = null;
    };
    plan_check = function(mob) {
        this = .tmp.epidemy;

        debug(mob,'pl_chk 0:start');

        var result;
        var total, city, plan_room;
        var i,mlist,m,icount,fidovnum;
        var planG, planD;
        planG = true; planD = true;
        city = mob.in_room.areaname;
        plan_room = mob.in_room;
        result = 0;

        /*
        * 0 - ты не последний зараженный
        * 1 - все заражены - собираемся до кучи
        * 2 - ты в куче, ждем остальных
        * 3 - я последний - вызываем "КРАКЕНА"
        */
        if(mob.epidemy.plan_room==null && mob.epidemy.plan==null) {
            debug(mob,'pl_chk 1:no plan, no plan_room');

            mlist = .tmp.epidemy.infected.clone();
            total = mlist.size();
            //заражены должны быть все spec_fido, зараженных должно быть не меньше 13 на город
            icount = 0; //зараженных в городе
            for( i=1 ; i<=total ; i=i+1 ) {
                m = mlist.back();
                mlist.pop_back();
                if(m.dead) {
                    .tmp.epidemy.infected.sub(m);
                    continue;
                }
                if(!m.online || (m.leader!=null && m.leader.pet==m)) {
                    continue;
                }
                //тварь в нашем городе
                if (m.in_room.areaname == city){
                    icount=icount+1;
                    //фидо-лайк-тварь (их и будем проверять)
                    if(m.pIndexData.spec_fun == 'spec_fido') {
                        fidovnum = m.pIndexData.vnum;
                    }
                }
            }

            //должны быть заражены все fido-like, зараженных не меньше 13
            if(fidovnum!=null && icount >= 13 ) {
                debug(mob,'pl_chk 2:fido:'+fidovnum+' count:'+icount);

                mlist = .get_mob_index(fidovnum).instances.clone();

                result = 1;
                total = mlist.size();
                //все ли spec_fido в городе заражены
                for( i=1 ; i<=total ; i=i+1 ) {
                    m = mlist.back();
                    //тварь в нашем городе, но не инфицирована
                    if(m.in_room.areaname==city && m.epidemy==null){
                        debug(mob,'pl_chk 3: not infected fido in room:'+m.in_room.name+'['+m.in_room.vnum+']');
                        planG = false; planD = false; result = 0;
                    }
                    mlist.pop_back();
                }

                mlist = .tmp.epidemy.infected.clone();
                total = mlist.size();
                for( i=1 ; i<=total ; i=i+1 ) {
                    m = mlist.back();
                    mlist.pop_back();
                    if(m.leader!=null && m.leader.pet==m){
                        continue;
                    }
                    if(m.in_room.areaname==city) {
                        clearGPS(m);
                        if(planG) {
                            debug(mob,'pl_chk 4: plan=1 for '+m.name+' in room:'+m.in_room.name+'['+m.in_room.vnum+'] -> '+plan_room.name+'['+plan_room.vnum+']');
                            //если планГ утвержден, прописываем всем в городе
                            m.epidemy.plan = 1;
                            m.epidemy.plan_room = plan_room;
                        } else {
                            debug(mob,'pl_chk 5: no plan for '+m.name+' in room:'+m.in_room.name+'['+m.in_room.vnum+']');
                            //ни у кого нет плана
                            m.epidemy.plan = 0;
                            m.epidemy.plan_room = null;
                        }
                    }
                }
                //}
            } else {
                debug(mob,'pl_chk 6: plan G fail. plan D fail.');
                planG = false; planD = false;
            }
        }

        //если план Д еще не отменился, проверим...
        if(planD) {
            debug(mob,'pl_chk 7: plan D check start.');
            if(mob.in_room == mob.epidemy.plan_room) {
                debug(mob,'pl_chk 8: in plan room: '+mob.in_room.name+'['+mob.in_room.vnum+']');
                result = 2;
            } else {
                debug(mob,'pl_chk 9: not in room');
                result = 1;
                planD = false;
            }
            icount = 0;
            mlist = .tmp.epidemy.infected.clone();
            total = mlist.size();
            for( i=1 ; i<=total ; i=i+1 ) {
                m = mlist.back();
                mlist.pop_back();
                if(!m.online || (m.leader!=null && m.leader.pet==m)) {
                    continue;
                }
                if(m.in_room.areaname==city && m.in_room!=plan_room){
                    planD = false;
                }

                if(planD)
                    icount=icount+1;

            }

            debug(mob,'pl_chk 10: plan D:'+planD+'. infected:'+icount);

            //если планД утвержден, назначем ответственного за геноцид
            if(planD && icount>=13) {
                result = 3;
            }
        }

        debug(mob,'pl_chk 11: end. result: '+result);

        return result;
    };
    explode_in_room = function(room) {
        var l,i,c,m;
        var ash;
        //try {
        room.ppl.forEach( function(){ act('Отвратительные существа вспыхивают темно-фиолетовым пламенем...');} );

        l = .tmp.epidemy.infected.clone();
        c = l.size();
        for(i=0;i<c;i=i+1){
            m = l.back();
            if(m.in_room==room && m.is_npc()){
                ash = .get_obj_index(.tmp.epidemy.ashVnum).create();
                ash.obj_to_room(room);
                ash.timer = 5;
                ash.description = 'Горсть пепла (ash) останков '+m.seeName(m,2)+'{G лежит у твоих ног.{x';

                m.extract(true);
            }
            l.pop_back();
        }
        /*} catch(e) {
            .get_char_world('miyamoto').ptc("epidemy.explode_in_room: " + e);
        }*/
    };

    fillEmotes = function(){
        this = .tmp.epidemy;

        //массивы социалов для зараженных
        emoteArray = .Array();
        emoteArray[0] = 'bounce self';  emoteArray[1] = 'burp self';
        emoteArray[2] = 'burp';         emoteArray[3] = 'confused';
        emoteArray[4] = 'conspire';     emoteArray[5] = 'cough';
        emoteArray[6] = 'fart';         emoteArray[7] = 'glare';
        emoteArray[8] = 'grimace';      emoteArray[9] = 'growl';
        emoteArray[10] = 'lick self';   emoteArray[11] = 'moan';
        emoteArray[12] = 'nail self';   emoteArray[13] = 'puke';
        emoteArray[14] = 'stagger';     emoteArray[15] = 'slobber';
        emoteArray[16] = 'twitch';      emoteArray[17] = 'wince';
        emoteArray[18] = 'fume';        emoteArray[19] = 'flinch';
        emoteArray[20] = 'rub self';    emoteArray[21] = 'sneeze';

        emoteTargArray = .Array();
        emoteTargArray[0] = "puke";
        emoteTargArray[1] = "stagger";
        emoteTargArray[2] = "growl";
    };
    fillTriggers = function () {
        this = .tmp.epidemy;

        if(triggers == null)
            triggers = .Map();

        triggers.infectedPostSpec = function(mob){
            try{
            this = .tmp.epidemy;
            if(.chance(1)) {
                transform(mob);
            } else if(.chance(5)) {
                mob.act("Ты корчишься в мучениях сопротивляясь {Dтёмным силам{x внутри себя!");
                mob.recho("%1$^C1 дрожит и корчится сопротивляясь {Dтёмным силам{x внутри себя!", mob);
            }
            }catch(e){
                var me;
                me = .get_char_world('miyamoto');
                if(me!=null)
                    me.ptc('epidemy.infectedPostSpec:'+e);
            }
        };
        triggers.sickPostSpec = function (mob) {
            if(mob.dead) return;

            this = .tmp.epidemy;

            try {
                if(mob.epidemy.plan!=null)
                    debug(mob,'postSpec 0: start. plan:'+mob.epidemy.plan);
                else
                    debug(mob,'postSpec 0: start. plan:null');

                if(mob.epidemy==null) throw('NO epidemy Map\n');

                if(mob.epidemy.victims==null) {
                    mob.epidemy.victims = getVictims(mob);
                }
               debug(mob,'postSpec 1: victims:'+mob.epidemy.victims.size());

                if(mob.epidemy.plan != null && mob.epidemy.plan >= 1 && mob.epidemy.plan_room==null) {
                    mob.epidemy.plan = null;
                    debug(mob,'postSpec 2: no plan_room -> plan=null');
                }

                if(mob.epidemy.plan == null) {
                    mob.epidemy.plan = plan_check(mob);
                    debug(mob,'postSpec 3: after plan_check: plan:'+mob.epidemy.plan);
                }

                if(mob.epidemy.plan == 2 && mob.epidemy.plan_room!=mob.in_room) {
                    mob.epidemy.plan = 1;
                    debug(mob,'postSpec 4: not in plan_room: plan:'+mob.epidemy.plan);
                }
                if(mob.epidemy.plan == 1 && mob.epidemy.plan_room==mob.in_room) {
                    mob.epidemy.plan = null;
                    debug(mob,'postSpec 5: in plan_room: plan=null');
                }

                if(mob.epidemy.plan == 3) {
                    debug(mob,'postSpec 6: plan:'+mob.epidemy.plan+'. check plan...');
                    //бывает что какая-то зверюга убегает в последний момент
                    mob.epidemy.plan = plan_check(mob);
                    debug(mob,'postSpec 7: after plan_check plan:'+mob.epidemy.plan);
                    //и если план без изменений
                    if(mob.epidemy.plan == 3) {
                        debug(mob,'postSpec 8: demon time.');

                        var demon_room;

                        demon_room = mob.in_room;
                        //взорвать всех зверюг в комнате
                        explode_in_room(demon_room);
                        //вызывать демона
                        get_one_demon(demon_room);

                        return;
                    }
                }

                //собака-кусака!
                if(mob.epidemy.victims.size() && .chance(10)) {
                    debug(mob,'postSpec 9: собака-кусака');
                    //кусаем если есть кого
                    var vict;
                    vict = mob.epidemy.victims.random();
                    if(vict.dead || vict.in_room!=mob.in_room || vict.epidemy!=null){
                        //изчез куда-то гад!!!
                        mob.epidemy.victims = null;
                    } else {
                        /*---некотролируемая эпидемия начинается здесь---*/
                        mob.act("Повинуясь {Dтёмным силам{x внутри себя, ты кусаешь %1$C2!", vict);
                        vict.act("Повинуясь {Dтёмным силам{x внутри себя, %1$C1 кусает тебя.{/Частичка {Dтемных сил{x проникает в тебя!", mob);
                        mob.rvecho(vict,"%1$^C1, повинуясь {Dтёмным силам{x внутри себя, кусает %2$C4.{/Частичка {Dтёмных сил{x проникает в %2$C4!", mob, vict);
                        vict.postSpec = function(){if(.chance(10)) {.tmp.epidemy.infect(this);}};
                        /*----------------------------------------------*/
                        mob.epidemy.victims.sub(vict);
                    }
                    return;
                }

                //собака - гуляка!
                /*plan:
                * 0 - ты не последний зараженный
                * 1 - все заражены - собираемся до кучи
                * 2 - ты в куче, ждем остальных
                * 3 - я последний - вызываем "КРАКЕНА"
                */
                if(mob.epidemy.plan==1 && .chance(50) && !(mob.leader!=null && mob.leader.pet==mob)) {
                    debug(mob,'postSpec 10: собака-гуляка');
                    if(mob.epidemy.plan_room==null)
                        throw('собака-гуляка '+mob.name+':plan_room==null;in_room:'+mob.in_room.name+'('+mob.in_room.vnum+')\n');

                    if(mob.epidemy.plan_way==null) {
                        debug(mob,'postSpec 10.1: no plan_way');
                        if(!mob.epidemy.plan_room.isCommon()) {
                            debug(mob,'postSpec 10.1.1: plan_room isCommon');
                            mob.epidemy.plan = null;
                            mob.epidemy.plan_room = null;
                            //return;
                        } else {
                            //ищем путь
                            debug(mob,'postSpec 10.1.2: try to find way');
                            mob.interpret('ponder');
                            mob.epidemy.plan_way = find_way(mob,mob.epidemy.plan_room);
                            if(mob.epidemy.plan_way.size()>0){
                                mob.epidemy.plan_waypoint = mob.in_room;
                                return;
                            } else {
                                // беда! пустой маршрут
                            }
                        }
                    } else if(mob.epidemy.plan_nextroom == null) {
                        debug(mob,'postSpec 10.2: plan_nextroom==null. try to make move');
                        make_your_move(mob);
                    } else if (mob.epidemy.plan_waypoint!=mob.in_room) { //сбились с маршрута
                        debug(mob,'postSpec 10.3: plan_waypoint!=mob.in_room. сбились с маршрута');
                        mob.epidemy.plan_waypoint = null;
                        mob.epidemy.plan_nextroom = null;
                        mob.epidemy.plan_way = null;
                    } else { //маршрут есть и мы с него не сбились
                        debug(mob,'postSpec 10.4: on my way');
                        if(.chance(20)) {
                            debug(mob,'postSpec 10.4.1: my chance');
                            var exitDoor;
                            exitDoor = mob.in_room.doorTo(mob.epidemy.plan_nextroom);

                            if(mob.in_room.getExitFlags(exitDoor) & .tables.exit_flags.closed) {
                                debug(mob,'postSpec 10.4.1.1: двери будь они неладны');

                                if(.chanceOneOf(4))
                                {
                                    mob.recho('%1$^C1 бьётся головой в %2$N4. Закрыто.',mob,mob.in_room.exitShortDescr(exitDoor));
                                }
                            else if(.chanceOneOf(3))
                                {
                                    mob.recho('%1$^C1 жалобно скулит и скребётся в %2$N4. Тщетно.',mob, mob.in_room.exitShortDescr(exitDoor));
                                }
                            else if (.chanceOneOf(2))
                                {
                                    var ppllist, sucker;
                                    ppllist = mob.in_room.ppl.clone();
                                    ppllist.sub(mob);
                                    if(ppllist.size()>0) {
                                        sucker = ppllist.random();
                                        sucker.recho('%1$^C1 садится перед %2$N5, и жалобно смотрит в глаза %3$C3.',mob, mob.in_room.exitShortDescr(exitDoor), sucker);
                                        sucker.act('%1$^C1 садится перед %2$N5, и жалобно смотрит тебе в глаза.',mob, mob.in_room.exitShortDescr(exitDoor));
                                    } else {
                                        mob.recho('%1$^C1 садится перед %2$N5, и жалобно завывает.',mob, mob.in_room.exitShortDescr(exitDoor));
                                    }
                                }
                            else
                                {
                                    mob.recho('На мгновение в глазах %1$C1 вспыхивает искра интеллекта.',mob);
                                    mob.interpret('open '+mob.in_room.doorName(exitDoor));
                                }

                                return;
                            } else {
                                debug(mob,'postSpec 10.4.1.2: need a second chance');

                                if(.chanceOneOf(3)) {
                                    mob.recho("%1$^C1 ходит кругами и нюхает следы. Этим что, можно ещё и нюхать?!",mob);
                                } else if(.chanceOneOf(2)) {
                                    mob.in_room.ppl.forEach(function (mob) {act("%1$^C1 принюхивается. Ты и представить себе не мог%2$Gло||ла, что ЭТИМ можно нюхать!",mob,this);},mob);

                                } else {
                                    debug(mob,'postSpec 10.4.1.2.3: try to make a move');

                                    make_your_move(mob);

                                }
                                return;
                            }


                        } else {
                            debug(mob,'postSpec 10.4.2: not a chance');

                        }
                    }
                }

                //собака-кривляка!
                if(.chance(5)) {
                    debug(mob,'postSpec 12: собака-кривляка');

                    //спамим всякими социалами
                    if (mob.in_room.ppl.size()<2)
                        return;

                    var numba,temotes,emotes;
                    emotes = emoteArray.keys.size();
                    temotes = emoteTargArray.keys.size();
                    numba = .number_range(0, (temotes+emotes-1));

                    if (numba > (emotes-1)) {
                        var target;
                        var str;
                        numba = numba - emotes;

                        if(emoteTargArray[numba]==null)
                        throw 'epidemy: mob.onSpec: нет такой emoteTargArray';

                        for(target=mob.in_room.ppl.random();target==mob;target=mob.in_room.ppl.random()) {}

                        str = emoteTargArray[numba] + ' ' + target.name;
                        mob.interpret(str);
                    } else {
                        mob.interpret(emoteArray[numba]);
                    }
                    return;
                }
            } catch(e){
                var me;
                me = .get_char_world('miyamoto');
                if(me!=null)
                    me.ptc('epidemy.sickPostSpec:'+e);
            }
        };

        /*onSpell(ch, spell, before) - ch пытается колдовать на нас заклинание spell,
        где spell - англ название умения. Вызывается дважды, причем before будет равно true перед кастом,
        и false - после каста. Если вернуть true из первого вызова, то заклинание выполнено не будет.
        Если вернуть true из второго вызова, то отрицательной реакции на атакующее заклинание не последует.  */
        triggers.infectedOnSpell = function(mob, ch,spell,before) {
            this = .tmp.epidemy;
            //dispel evil
            if(before){
                if(spell == 'dispel evil' || spell == 'heal' || spell == 'superior heal') {
                    mob.recho("%1$^C1 одной стороной чихает, другой выпускает {Dтёмное облочко{x...", mob);
                    return true;
                }
            } else {
                if(spell == 'dispel evil' || spell == 'heal' || spell == 'superior heal') {
                    heal(mob);
                    return true;
                }
            }
            //ray of truth
            return false;
        };
        triggers.sickOnSpell = function(mob,ch,spell,before) {
            this=.tmp.epidemy;
            //dispel evil
            if(before){
                if(spell == 'dispel evil' || spell == 'ray of truth'
                    || spell == 'wrath' || spell == 'banishment') {
                    mob.recho("%1$^C1 одной стороной чихает, другой выпускает {Dтёмное облочко{x...", mob);
                    return true;
                }
            } else {
                if(spell == 'dispel evil' || spell == 'ray of truth'
                    || spell == 'wrath' || spell == 'banishment') {
                    heal(mob);
                    return true;
                }
            }
            //ray of truth
            return false;
        };

        //onDeath(ch) - ch убил нас. если вернуть true, мы не умрем и останемся стоять
        triggers.infectedOnDeath = function(mob,ch) {
            //выпиливаемся из списка
            .tmp.epidemy.infected.sub(mob);
        };
        triggers.infectedOnExtract = function(mob,count) {
            //выпиливаемся из списка
            .tmp.epidemy.infected.sub(mob);
        };

        //onLeave(ch, from_room, movetype) - ch только что вышел из нашей комнаты
        triggers.sickOnLeave = function(mob, ch, from_room, movetype) {
            mob.epidemy.victims = null;
        };

        //onEntry() - мы вошли в какую-то комнату
        triggers.sickOnEntry = function(mob) {
            mob.epidemy.victims = null;
        };

        //onGreet(ch) - ch вошел в нашу комнату
        triggers.sickOnGreet = function(mob, ch) {
            mob.epidemy.victims = null;
        };

        //onDeath(ch) - ch убил нас. если вернуть true, мы не умрем и останемся стоять
        triggers.sickOnDeath = function(mob, ch) {
            this=.tmp.epidemy;
            //выпиливаемся из списка
            infected.sub(mob);

            //отменяем план
            if(mob.epidemy.plan!=null)
                plan_cancel(mob);

            //вылупляем импа
            if(ch!=null && imp_list!=null && imp_list.size()>0
                && initImp!=null && !imp_list.has(pIndexData)) {
                var imp;
                imp = imp_list.random().create();
                initImp(imp);
                imp.char_to_room(ch.in_room);
                imp.epidemy.fearList.push_back(ch);
                ch.in_room.echo('Из останков %1$C1, весь в кишках и ошметках, вылезает %2$C1.',mob,imp);
            }
        };

    };
    fillInfected = function() {
        var i, result;

        result = .List();

        for (i = .char_list; i != null; i = i.next) {
            if (i.is_npc() && i.epidemy != null && (i.epidemy.infected!=null && i.epidemy.infected==true) && !i.dead) {
                result.push_back(i);
            }
        }
        return result;
    };
    debug = function(mob,str) {
        if(!.buildplot || mob.epidemy.debug==null || mob.epidemy.debug==false)
            return;

        .get_char_world('miyamoto').act('debug:%1$C1 [%2$d] %3$s',mob,mob.in_room.vnum,str);
    };

    setInfectedTriggers = function(mob) {
        mob.postSpec = function(){.tmp.epidemy.triggers.infectedPostSpec(this);};
        mob.onSpell = function(ch,spell,before){if(.tmp.epidemy.triggers.infectedOnSpell(this,ch,spell,before)) return true;};
        mob.onDeath = function(ch){.tmp.epidemy.triggers.infectedOnDeath(this,ch);};
        mob.onExtract = function(count){.tmp.epidemy.triggers.infectedOnExtract(this,count);};

        return mob;
    };
    setSickTriggers = function(mob) {
        mob.postSpec = function(){.tmp.epidemy.triggers.sickPostSpec(this);};
        mob.onSpell = function(ch,spell,before){if(.tmp.epidemy.triggers.sickOnSpell(this,ch,spell,before)) return true;};
        mob.onLeave = function(ch, from_room, movetype){.tmp.epidemy.triggers.sickOnLeave(this,ch, from_room, movetype);};
        mob.onEntry = function(){.tmp.epidemy.triggers.sickOnEntry(this);};
        mob.onGreet = function(ch){.tmp.epidemy.triggers.sickOnGreet(this, ch);};
        mob.onDeath = function(ch){.tmp.epidemy.triggers.sickOnDeath(this,ch);};

        return mob;
    };

    fillTriggers();
    fillEmotes();
    //список зараженных
    infected = fillInfected();

    //перепрошивка зараженных из списка свежими тригерами
    infected.forEach(function () {
        epidemy.plan_way = null;
        epidemy.plan_waypoint = null;
        epidemy.plan_nextroom = null;
        this = .tmp.epidemy.setInfectedTriggers(this);
        if(epidemy.name!=null)
            this = .tmp.epidemy.setSickTriggers(this);

    });
})

//Name: [fido dog зверюга] Vnum: [3062] Spec fun: [spec_fido] Size: [small]
//Name: [alley cat feline кот] Vnum: [9543] Size: [small]
//Name: [vulture стервятник] Vnum: [9544] Spec fun: [spec_fido] Size: [small]
//eval looking4fido = function(sf,ch) {for(i=.char_list;i!=null;i=i.next) {if(i.pc!=null) {continue;} if(i.pIndexData.spec_fun==sf) ch.ptc(''+i.pIndexData.vnum+i.name+'\n');}}

